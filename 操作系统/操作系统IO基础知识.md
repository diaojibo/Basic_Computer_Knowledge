## I/O设备
I/O设备大致分为两类

### 块设备
信息存储在固定大小的块中，每个块都有自己的地址，是可寻址的。如硬盘，USB盘，ROM

### 字符设备
字符设备以字符为单位发送或者接受一个字符流，不考虑任何块结构，是不可寻址的，也没有任何寻道操作。比如打印机，网络接口，鼠标。

### 其他
以上分类并不完美，比如时钟，工作是按照预定的时间间隔产生中断，海油内存映射的显示器也不符合以上模型。

## 设备控制器
I/O设备一般由机械部件和电子部件两部分组成，电子部分称作**设备控制器**或者**适配器**。

![](image/io.png)

控制器的任务是把串行的位流转换成字节块

## 内存映射
内存映射是指将硬盘上文件的位置与进程逻辑地址空间中一块大小相同的区域一一对应，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据在用户空间和内核空间之间的拷贝操作。当大量数据需要传输的时候，采用内存映射方式去访问文件会获得比较好的效率


## 缓存IO
对于IO设备，缓冲是一个重要问题。
![](image/buffer.jpg)

### 用户缓冲区
一种改进措施是，在用户空间设置缓冲区提高效率。但是万一缓冲区被分页出去了则相当危险，这要锁定内存，但是锁定内存降低分页效率。

### 内核缓冲区
另一种改进是在内核空间创建一个缓冲区，该缓冲区满的时候，将用户缓存区调入内存,并把内核缓存区的内容复制过用户缓存区去。

### 双缓冲区
只用一个内核缓冲区的话，当内核缓冲区满并且还没写入用户缓冲区的时候将无法写入数据。所以设置两个内核缓冲区做缓冲，一个满了的时候临时使用另外一个。

### 循环缓冲区
被广泛使用，一个内存区域设置两个指针，一个指向下一个空闲位置，一个指向数据位置。两个指针环绕，并且到达顶部时返回底部。

## 操作系统操作IO
上面我们稍微解释了一下，io缓存的基本原理。那么操作系统操作io的时候具体是如何的呢？

我们对一个文件的读写，都会通过内核提供的系统调用，内核会给我们返回一个 File Descriptor(详见linux笔记)，这个描述符是一个数字(指代打开了什么文件的)，指向内核的一个结构体(也就是缓存IO体系中内核态里的缓冲区)，我们应用程序对文件的读写就是对描述符指向的结构体的读写。

Linux 会把内存分为 内核区和用户区。Linux 的内核区会帮我们管理所有的硬件资源，并且会提供系统调用，我们应用程序的读操作，就会通过系统调用 read 发起一个读操作，这个时候，内核就会创建一个文件描述符，通过驱动向硬件发送读指令，并且把读的数据放在描述符指向的结构体的缓冲区中。当这个数据传到用户区的时候，就完成了一次 IO。

Linux 系统调用的 read，是一个阻塞函数。这个我们应用程序在发起read系统调用的时候，就必须要阻塞，进程挂起，等待文件描述符的读就绪。

从上面我们可以知道，应用程序的一个 read系统调用，需要经过：
 - 硬件读取文件数据到文件描述符指向的结构体的缓冲区。
 - 结构体的缓冲区的数据 传输到 用户区。
