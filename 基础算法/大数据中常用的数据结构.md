## 大数据处理常用的结构

### 倒排索引
以英文为例，下面是要被索引的文本：

```
T0 = "it is what it is"
T1 = "what is it"
T2 = "it is a banana"
```

我们就能得到下面的反向文件索引：
```
"a":      {2}
"banana": {2}
"is":     {0, 1, 2}
"it":     {0, 1, 2}
"what":   {0, 1}
```
检索的条件"what","is"和"it"将对应集合的交集。

正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而**反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系**。

**问题实例：文档检索系统**，查询那些文件包含了某单词，比如常见的学术论文的关键字搜索。


### 外排序
适用范围：大数据的排序，去重

外排序（External sorting）是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。尔后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。

外排序是指在排序期间全部对象个数太多，不能同时存放在内存，必须根据排序过程的要求，不断在内、外存之间移动的排序。**比如常见的有外归并排序**。

基本原理及要点：外排序的归并方法，置换选择败者树原理，最优归并树

扩展：

问题实例：

有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16个字节，内存限制大小是1M。返回频数最高的100个词。

这个数据具有很明显的特点，词的大小为16个字节，但是内存只有1m做hash有些不够，所以可以用来排序。内存可以当输入缓冲区使用。

### trie树
Trie树的名字有很多，比如字典树，前缀树等等。

Trie树，即字典树，又称单词查找树或键树，是一种树形结构。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是最大限度地减少无谓的字符串比较，查询效率比较高。

Trie的**核心思想是空间换时间**，利用**字符串的公共前缀来降低查询时间的开销以达到提高效率的目的**。

![](image/trie0.png)

从上面的图中，我们或多或少的可以发现一些好玩的特性。

1. 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。

2. 从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。

3. 每个单词的公共前缀作为一个字符节点保存。

前缀树主要有其作用。


第一：词频统计。可能有人要说了，词频统计简单啊，一个hash或者一个堆就可以打完收工，但问题来了，如果内存有限呢？还能这么玩吗？所以这里我们就可以**用trie树来压缩下空间**，因为公共前缀都是用一个节点保存的。

第二: 前缀匹配就拿上面的图来说吧，如果我想获取所有以"a"开头的字符串，从图中可以很明显的看到是：and,as,at，如果不用trie树，你该怎么做呢？很显然朴素的做法时间复杂度为O(N2) ，**那么用Trie树就不一样了，它可以做到h，h为你检索单词的长度**，可以说这是秒杀的效果。

**插入和查询的效率很高，都为O(m)，其中 m是待插入/查询的字符串的长度。**

**zwlj：然而工程上大部分场合还是用hash，因为好实现，效率也不低。**
