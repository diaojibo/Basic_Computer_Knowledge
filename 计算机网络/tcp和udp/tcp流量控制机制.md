## 流量控制
tcp采用滑动窗口机制来进行流量控制flow control。

就是让发送方不要发的太快，要让接收方来得及接受。

通过在tcp头部设置接受窗口的大小，告诉对方控制发送窗口不能超过我的接受窗口。

此时，还需要考虑一个**死锁**问题，就是假设我告诉了对方我的接受窗口设置为0(缓存没有空间了)，过了一段时间后，缓存又空出来了，这时发送了一个设置接受窗口为非零值得报文给对方。**但是这个报文如果丢失的话，就会产生死锁**。因为两边都在等对方发送数据。

为了解决上述问题，设置了一个**持续计时器persistent timer**，只要收到对方的0窗口通知，就启用这个timer，每隔一定时间，就发送仅携带1字节数据的探测报文，从而打破死锁。

### 糊涂窗口(零窗口)综合征
在流量控制中，会遇到糊涂窗口综合征这个问题。就是指当发送端应用进程产生数据很慢、或接收端应用进程处理接收缓冲区数据很慢，或二者兼而有之；就会**使应用进程间传送的报文段很小，特别是有效载荷很小**； 极端情况下，有效载荷可能只有1个字节；传输开销有40字节(20字节的IP头+20字节的TCP头) 这种现象。

比如说典型的，telnet中我每次只传输1个字符，或者是对方的缓存满了，接受窗口只有1字节，我每次只能发送1.这都导致了糊涂窗口综合征。

最后nagle算法用来解决这种如何组装报文段的问题。
### 报文段组装发出
什么时候将缓存中的字节组装成一个报文发出去呢？

有几种情况

 - 默认的情况下就是将**阈值变量设置成一个MSS**，达到MSS，就组成一个发出去。
 - 某个计时器超时
 - 设置了push字段。

这几种情况还不够，有时必须要采取一些手段进行额外控制。比如telnet这种交互式协议，假如我们每次只发送一个字节的数据，但header字节数很大，显然很浪费。

因此对于接收方，将会尽量采用**推迟确认**，和**捎带确认piggybacking**的方法。**捎带确认就是指，收到数据后不立刻发送确认，而是等到有真的数据要传递时，再设置确认的一种搭便车的方法。**

**发送方则广泛采用nagle算法。**

#### nagle算法
发送方广泛采用nagle算法。这个算法可用于解决“小包”问题(糊涂窗口综合征)。

Nagle算法的基本定义是**任意时刻，最多只能有一个未被确认的小包**。

Nagle算法的规则
1. 如果包长度达到MSS，则允许发送；
2. 如果该包含有FIN，则允许发送；
3. 设置了TCP_NODELAY选项，则允许发送；
4. 未设置TCP_CORK选项时，若所有发出去的**小数据包（包长度小于MSS）均被确认**，则允许发送；
5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。

Nagle算法**只允许一个未被ACK的包存在于网络**，它并不管包的大小，因此它事实上就是一个扩展的停-等协议，只不过它是基于包停-等的，而不是基于字节停-等的，换句话说，这有点像大包MSS用流水线，小包用停等协议。

##### 深化理解(zwlj)
nagle算法本质上就是防止小包问题的。TCP想**尽量让每个包都组成MSS大小发送出去**，不浪费。

所以nagle流程就是，当缓冲里有一些数据大于MSS，就把数据先拆成n个MSS包，然后用pipeline方式发出去，末尾的**小包不立刻发送**，而是等待下一个发送的时机，比如时间到了，设置了某些字段，又或者是跟新的数据组装到了一起达到MSS才发出去

除非之前的小包得到了确认，否则就不把小包发出去，所以这里有点像是**只针对于小包的停止等待协议**，保证了只有一个未确认的小包在网络中。一旦包大于MSS，都是使用pipelining的方式发送。

### 总结
流量控制，采用滑动窗口机制实现(报文中告诉对方自己的接受窗口)。

**为了解决小包问题(糊涂窗口综合征)，发送方采用nagle算法，接受方适当延迟确认和捎带确认。**
