## 比特币源码阅读
进入比特币的src目录，进行源码阅读。

网络上已经将bitcoin源码的各个模块都划分好了：


![](image/bitcoin9.png)

![](image/bitcoin10.png)


main函数在bitcoind.cpp文件中。main函数的运行流程大致如下：

![](image/bitcoin0.jpg)

### 区块Block部分
区块链，当然Block就是一个重要的数据结构。可以从这个角度先入手，全局搜索Block.h的话，可以找到Block数据结构的代码位置。或者根据上面的模块图也能清晰的看到，Block位于primitives 原始目录下。

#### CBlockHeader
位于block.h下

```
/** Nodes collect new transactions into a block, hash them into a hash tree,
 * and scan through nonce values to make the block's hash satisfy proof-of-work
 * requirements.  When they solve the proof-of-work, they broadcast the block
 * to everyone and the block is added to the block chain.  The first transaction
 * in the block is a special one that creates a new coin owned by the creator
 * of the block.
 *
 **网络中的节点不断收集新的交易打包到区块中，所有的交易会通过两两哈希的方式形成一个Merkle树
 * 打包的过程就是要完成工作量证明的要求，当节点解出了当前的随机数时，
 * 它就把当前的区块广播到其他所有节点，并且加到区块链上。
 * 区块中的第一笔交易称之为CoinBase交易，是产生的新币，奖励给区块的产生者  
 *
 * add by chaors 20180419
 */

class CBlockHeader
{
public:
    // header
    int32_t nVersion;       //版本
    uint256 hashPrevBlock;  //上一个区块的hash
    uint256 hashMerkleRoot; //包含交易信息的Merkle树根
    uint32_t nTime;         //时间戳
    uint32_t nBits;         //工作量证明(POW)的难度
    uint32_t nNonce;        //要找的符合POW的随机数

    CBlockHeader()          //构造函数初始化成员变量
    {
        SetNull();          
    }

    ADD_SERIALIZE_METHODS;  //通过封装的模板实现类的序列化

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action) {
        READWRITE(this->nVersion);
        READWRITE(hashPrevBlock);
        READWRITE(hashMerkleRoot);
        READWRITE(nTime);
        READWRITE(nBits);
        READWRITE(nNonce);
    }

    void SetNull()          //初始化成员变量
    {
        nVersion = 0;
        hashPrevBlock.SetNull();
        hashMerkleRoot.SetNull();
        nTime = 0;
        nBits = 0;
        nNonce = 0;
    }

    bool IsNull() const
    {
        return (nBits == 0);     //难度为0说明区块还未创建，区块头为空
    }

    uint256 GetHash() const;     //获取哈希

    int64_t GetBlockTime() const //获取区块时间
    {
        return (int64_t)nTime;
    }
}
```

有关区块，在区块链的笔记中都有提到了，上面的注释也写的比较清楚了。首先我们会收集很多交易，然后打包到区块中，打包的过程是利用了交易进行hash运算，构造一个Merkle树。任何一个交易的改变都可能引起Merkle树的变化。然后我们枚举随机数 计算 `hash = f(newBlock||prevHash||number)`.当符合一定要求了，那么我们就完成了工作量证明。然后此时我们就会广播这个区块给其他节点，附加到区块链上。

**区块中第一笔交易称为CoinBase交易，是产生的新币，奖励给区块的生产者。所以当区块最终能成功入链，生产者就会得到奖励，这就是挖矿。**

这就是Block的header类。接下来看看CBlock本体类

#### CBlock
CBlock直接继承了CBlockHeader

```
class CBlock : public CBlockHeader         //继承自CBlockHeader，拥有其所有成员变量
{
public:
    // network and disk
    std::vector<CTransactionRef> vtx;      //所有交易的容器

    // memory only
    mutable bool fChecked;                 //交易是否验证

    CBlock()
    {
        SetNull();
    }

    CBlock(const CBlockHeader &header)
    {
        SetNull();
        *((CBlockHeader*)this) = header;
    }

    ADD_SERIALIZE_METHODS;

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action) {
        READWRITE(*(CBlockHeader*)this);
        READWRITE(vtx);
    }

    void SetNull()
    {
        CBlockHeader::SetNull();
        vtx.clear();
        fChecked = false;
    }

    CBlockHeader GetBlockHeader() const
    {
        CBlockHeader block;
        block.nVersion       = nVersion;
        block.hashPrevBlock  = hashPrevBlock;
        block.hashMerkleRoot = hashMerkleRoot;
        block.nTime          = nTime;
        block.nBits          = nBits;
        block.nNonce         = nNonce;
        return block;
    }

    std::string ToString() const;
};
```

#### CBlockLocator

```
/** Describes a place in the block chain to another node such that if the
 * other node doesn't have the same branch, it can find a recent common trunk.
 * The further back it is, the further before the fork it may be.
 *
 **描述区块链中在其他节点的一个位置，
 *如果其他节点没有相同的分支，它可以找到一个最近的中继(最近的相同块)。
 *更进一步地讲，它可能是分叉前的一个位置
 */
struct CBlockLocator
{
    std::vector<uint256> vHave;

    CBlockLocator() {}

    explicit CBlockLocator(const std::vector<uint256>& vHaveIn) : vHave(vHaveIn) {}

    ADD_SERIALIZE_METHODS;

    template <typename Stream, typename Operation>
    inline void SerializationOp(Stream& s, Operation ser_action) {
        int nVersion = s.GetVersion();
        if (!(s.GetType() & SER_GETHASH))
            READWRITE(nVersion);
        READWRITE(vHave);
    }

    void SetNull()
    {
        vHave.clear();
    }

    bool IsNull() const
    {
        return vHave.empty();
    }
};
```

按照注释的说法，就是确认本节点的区块链，在其他某个节点中大概是个什么位置状态。找到最近的相同块，比如两节点可能从某个block开始出现了分叉，那么就能找到这个分叉。

#### cpp实现

```
uint256 CBlockHeader::GetHash() const
{
    return SerializeHash(*this);        //生成256位的哈希值
}

std::string CBlock::ToString() const    //区块对象格式化字符串输出
{
    std::stringstream s;
    s << strprintf("CBlock(hash=%s, ver=0x%08x, hashPrevBlock=%s, hashMerkleRoot=%s, nTime=%u, nBits=%08x, nNonce=%u, vtx=%u)\n",
        GetHash().ToString(),
        nVersion,
        hashPrevBlock.ToString(),
        hashMerkleRoot.ToString(),
        nTime, nBits, nNonce,
        vtx.size());
    for (const auto& tx : vtx) {
        s << "  " << tx->ToString() << "\n";
    }
    return s.str();
}
```

#### 区块结构分析

![](image/bitcoin11.png)

以前的笔记也有点到过区块的结构，本质上无非就是区块头和各个交易数据块的封装。交易数据块的验证又是根据Merkle树来进行。区块头就是CBlockHeader，80字节左右，而一个交易数据块却要250字节左右，具体到bitcoin，交易数据就是UTXO的转移。

![](image/bitcoin12.png)

![](image/bitcoin13.png)

#### 区块标识符
 - BlockHash 区块哈希值，是通过SHA256算法对区块头信息进行哈希得到的，这个值必须满足POW的DifficultyTarget，该区块才被认为有效。同时，也是**区块的唯一标识符**，**可以通过通过bitcoin-cli根据BlockHash查询区块信息(文章开头我们就使用过)**


 - BlockHeight 区块高度，是用来标示区块在区块链中的位置。**创世区块高度为0，每一个加在后面的区块，区块高度递增1**。**可以通过bitcoin-cli根据高度查询区块哈希值(文章开头我们就使用过)**

#### 创世区块
区块链上第一个区块被称为创世区块，它是所有区块的共同祖先。我们可以查看下比特币的创世区块：


利用bitcoin-cli可以查看到相应的结果。

![](image/bitcoin14.png)

这里需要说一下的就是，在交易Transaction的数据结构中，有个coinbase字段，这个字段可以填下交易人员想写的信息。而在这个创世区块中，中本聪也在一个交易块中，留下了他的coinbase留言：“The Times 03/Jan/2009 Chancellor on brink of second bailout forbanks.”这句话是泰晤士报当天的头版文章标题

### 参考

[比特币源码研读(1)bitcoin源码结构](https://juejin.im/post/5ae072a06fb9a07a9b35a0ee)
