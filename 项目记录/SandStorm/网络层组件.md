# 网络层组件
为了分布式通信系统的实现，编写了一套网络层组件，在sandstorm的network目录下。


## 线程安全的消息队列
ConcurrentQueue实现了一个线程安全的消息队列，利用了c++中的mutex和lock。

里面有push pop方法，每次调用时都会用lock_guard对消息队列上锁，注意pop方法中，使用std::move来触发移动构造函数(可见c++ move相关笔记)

除此之外还有Size方法和Empty方法，也是线程安全的方法。

## 线程池
线程池来管理线程，从而提高性能。

线程池的实现也并不复杂，头文件里定义了一个模板类，接受一个泛型Type。线程池类里封装了几个私有变量

 - _shutdown布尔值,指示线程池开关
 - _threads指示线程池容量大小(int32)
 - _handler指示线程池封装的执行函数
 - _workers是一个vector容器用来封装线程
 - _tasks封装了一个消息队列

此外，类中有一个Submit方法，用来提交一个Type的实例，handler里封装的function的函数恰好类型就是(Type->void)，所以每当有一个实例提交上来，线程池就会分配一个线程，然后传递参数执行handler方法。

**由于C++中模板的限制,无法将声明和实现分离，因此为了分离声明和实现，把线程池的实现代码写在了一个后缀为tcc的文件当中，意为模板实现C++代码，然后头文件末尾包含此tcc文件**

线程池tcc中的实现也很简洁，现在来考虑线程池的实现思想，我们需要一个在随时submit一个task进入池中，池子中如果没有空闲线程则不工作，如果有空闲线程则执行任务。那么我们投递的task进入哪里呢？显然就是**消息队列**。

那么具体线程池的实现就很明朗了，初始化线程vector，并且创建函数对象并且传递进去(使用lambda)。

``` c++
for (int32_t i = 0; i < _threads; ++i)
    _workers.emplace_back(
            [this] {
                while (!_shutdown) {
                    Type record;
                    _tasks.Pop(record, true);
                    _handler(record);
                }
            }
    );
```

如上代码，注意使用了vector的emplace_back方法而不是push_back，区别在于emplace_back方法是对于变量的原地构成(直接把临时变量拿来用),而push_back则会是先调用构造函数，再(可能)调用移动构造函数，再传值，再销毁临时变量，有消耗。

上面代码指示了，一个lambda函数，任务就是只要线程池没有关闭，就不断从线程安全的消息队列里取消息。执行任务。
