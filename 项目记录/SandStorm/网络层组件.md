# 网络层组件
为了分布式通信系统的实现，编写了一套网络层组件，在sandstorm的network目录下。


## 线程安全的消息队列
ConcurrentQueue实现了一个线程安全的消息队列，利用了c++中的mutex和lock。

里面有push pop方法，每次调用时都会用lock_guard对消息队列上锁，注意pop方法中，使用std::move来触发移动构造函数(可见c++ move相关笔记)

除此之外还有Size方法和Empty方法，也是线程安全的方法。

此类在util目录下

## 线程池
线程池来管理线程，从而提高性能。

线程池的实现也并不复杂，头文件里定义了一个模板类，接受一个泛型Type。线程池类里封装了几个私有变量

 - _shutdown布尔值,指示线程池开关
 - _threads指示线程池容量大小(int32)
 - _handler指示线程池封装的执行函数
 - _workers是一个vector容器用来封装线程
 - _tasks封装了一个消息队列

此外，类中有一个Submit方法，用来提交一个Type的实例，handler里封装的function的函数恰好类型就是(Type->void)，所以每当有一个实例提交上来，线程池就会分配一个线程，然后传递参数执行handler方法。

**由于C++中模板的限制,无法将声明和实现分离，因此为了分离声明和实现，把线程池的实现代码写在了一个后缀为tcc的文件当中，意为模板实现C++代码，然后头文件末尾包含此tcc文件**

线程池tcc中的实现也很简洁，现在来考虑线程池的实现思想，我们需要一个在随时submit一个task进入池中，池子中如果没有空闲线程则不工作，如果有空闲线程则执行任务。那么我们投递的task进入哪里呢？显然就是**消息队列**。

那么具体线程池的实现就很明朗了，初始化线程vector，并且创建函数对象并且传递进去(使用lambda)。

``` c++
for (int32_t i = 0; i < _threads; ++i)
    _workers.emplace_back(
            [this] {
                while (!_shutdown) {
                    Type record;
                    _tasks.Pop(record, true);
                    _handler(record);
                }
            }
    );
```

如上代码，注意使用了vector的emplace_back方法而不是push_back，区别在于emplace_back方法是对于变量的原地构成(直接把临时变量拿来用),而push_back则会是先调用构造函数，再(可能)调用移动构造函数，再传值，再销毁临时变量，有消耗。

上面代码指示了，一个lambda函数，任务就是只要线程池没有关闭，就不断从线程安全的消息队列里取消息。执行任务。

此类也在util目录下

## 字节序封装
见c++中的大小端字节序笔记，我们知道不同cpu处理自己的字节序不同，我们需要让这些字节在网络中传输，TCP规定要用大端，所以我们必须做一层封装，把当前字节序转换成大端。当然，也要封装方法，将tcp中的大端字节正确转换成当前cpu使用的字节。

头文件Exendian.h在utils目录下

## 序列化实现
手动实现一个字节流类，可参见序列化实现笔记，完全一模一样。

唯一的不同点在于，ByteReader里添加了转换网络中的大端字节数据的方法。可以让host使用的字节流与TCP字节流相互转化。

## 抽象TP传输层实现
我们利用epoll来实现对传输层的封装。

主要的类位于network目录下的Net.h头文件当中，内部定义了几个类

### Socket类
通用的套接字层，其实仅仅也就是对套接字文件描述符的一个封装，内部仅仅封装一个整数为socket的fd。析构函数中定义了close方法。


### IStream接口
通用数据流层，代表所有**可读写的数据流类接口**，可以理解为对输入输出字节流(ByteArray)数据的再一层封装，也就是说直接用它来操作IO数据,内部会有一个数据接收器datasink。里面的核心方法有

 - Recieve,指定一个缓冲区，数据流将**读取到的数据**填充到缓冲区。
 - Send,发送数据，将用户传递的字节数组发送出去。

### IConnectable
一个接口interface，表示某类可以**主动** 连接到其他服务器。**client** 都会实现这个接口,server不需要实现这个接口。

只有一个函数Connect,接受两个参数，远程主机名，和端口，用于连接到远端服务器。

### BasicStream
基本的数据流类，继承了IStream接口，也继承了Socket，也就是融合了Socket和IStream，即可通过Socket文件描述符，在此基础上来读写数据流。此外也封装了DataSink数据收集器。

### BasicServer
服务器类，继承了socket接口，封装了服务器的常用方法，如bind，accept，listen。

### DataSink\&\&PackageDataSink
DataSink是数据接受层，传输层接受到数据时会通过DataSink对象传输到外部

PacakgeDataSink就是DataSink的子类，它里面封装了一个ByteArray，可以通过Write方法，向io流(IStream)写数据(ByteArray).

## 基于epoll的TP传输层
