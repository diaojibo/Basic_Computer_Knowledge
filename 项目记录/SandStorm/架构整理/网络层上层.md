## 网络层上层封装


### CommandServer类
头文件在message目录下。顾名思义，CommandServer就是基于Command机制建立的Server类。

具有模板CommandServerContext，内部封装了：

 - 一个NetListenenr
 - 一个Map \_commandHanlders，用来存储具体Command收到时执行的方法。
 - \_connectHandler,一个函数，用以在连接成功时调用。

有成员函数

OnCommand方法，用来绑定Command和对应处理函数。要绑定的函数需要接受三个参数，CommandServerContext上下文，具体Command，Responser(也是一个函数，函数接受Response类作为参数)类，就是收到Response之后的处理函数。

OnConnection函数，绑定当连接建立时会调用的函数，这个绑定的函数需要接受一个参数TcpConnection类的一个**智能指针**。

#### StartListen方法

StartListen方法，开始监听。监听的时候会调用自身的NetListener的OnConnection方法，这样当NetListener监听到数据到来的时候，就会调用所绑定的方法。


### OutputDispatcher类
内部也封装了一个消息队列，消息队列内容为OutputItem。并且封装着Manager中所有的boltTaskQueue。

也就是说OutputDispatcher管理着，两类消息队列，一个是自身的消息队列，一个是BoltExecutor相关的消息队列容器。自身的消息队列OutputQueue，内部封装的元素OutputItem，其实就时封装了taskid和tuple(数据元组)

OutputDispatcher有一个Start方法用以启动，启动之后会创建一个新线程，这个线程执行一个永久循环，从OutputQueue中源源不断的取消息，判段这个消息(Output Item)来自哪里，要去哪里。

首先一个OutputItem封装了一个task Index，然后会从和根据这个task index找到对应的taskInfo对象，然后会根据这个task info找到对应的路径Path。最后把output item交由ProcessPath方法处理。

ProcessPath方法用于给对应的output item设置sourceTaskName和destTaskName。
