## 全局变量&全局静态变量

### 全局变量
全局变量是在所有函数体的外部定义的，程序 的所有地方可以使用。

我们可以在一个头文件定义全局变量，在cpp文件里include来使用。但要注意，不使用static(非全局静态变量)的时候，两个不同的定义此全局变量的源文件都可以正常编译，但会出现链接错误，原因是有两个地方存在相同的变量，导致编译器无法识别应该使用哪一个。

也就是说全局变量名字要唯一，否则不能链接通过。

定义了全局变量，也可以不引入头文件，然后用extern关键字来让外部使用。

### 静态全局变量
static关键字用于全局变量的声明时，作用类似于函数的情况，这个全局变量的作用域将局限在声明该变量的**c文件内部**，这个**c文件之外的代码将无法访问这个变量**。编译的时候将会出现类似undeference to "xxx"的报错，它是找不到xxx的，因为**使用static相当于进行了文件隔离**。


### 静态局部变量
在局部变量前，加上关键字static，该变量就被定义成为一个静态局部变量。

通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。 

**但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便**。 

静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。 

静态局部变量有以下特点： 

 - 该变量在全局数据区分配内存； 
 - 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； 
 - 静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0； 
 - 它始终驻留在全局数据区，直到程序运行结束。**但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束**；

### 静态函数
函数虽然准确来说不算变量，但是在这里也插入静态函数的定义吧。

在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。 

定义静态函数的好处： 

 - 静态函数不能被其它文件所用； （**限定作用域**）
 - 其它文件中可以定义相同名字的函数，不会发生冲突； 


### 静态数据成员
在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。先举一个静态数据成员的例子。 

``` cpp
#include<iostream>
using namespace std;
 
class Point
{
public:
	Point(int xx = 0, int yy = 0) { X = xx; Y = yy; countP ++; }
	Point(Point &p); 
	~Point() { countP --; }
	int GetX() { return X; }
	int GetY() { return Y; }
	void GetC() { cout << "Object id = " << countP << endl; } //输出静态数据成员
private:
	int X, Y;
	static int countP; //静态数据成员声明，用于记录点的个数
};
 
Point :: Point(Point &p)
{
	X = p.X;
	Y = p.Y;
	countP ++; //在构造函数中对countP累加，所有对象共同维护同一个countP
}
 
int Point :: countP = 0; //静态数据成员定义和初始化，使用类名限定

```

静态数据成员有以下特点： 

 - 对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷 贝，由该类型的所有对象共享访问。也就是说，静态数据成员是该类的所有对象所共有的。对该类的多个对象来说，静态数据成员只分配一次内存，供所有对象共 用。所以，静态数据成员的值对每个对象都是一样的，它的值可以更新； 

 - 静态数据成员存储在全局数据区。静态数据成员定义时要分配空间，所以不能在类声明中定义。在上例中，语句int Point::countP=0; 是定义静态数据成员； 

 - 静态数据成员和普通数据成员一样遵从public,protected,private访问规则； 
 - 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它


### 静态成员函数
与静态数据成员一样，我们也可以创建一个静态成员函数，它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数与静态数据成员一样，都是类的内部 实现，属于类定义的一部分。 普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身，因为普通成员函数总是具体的属于某个类的具体对象的。通常情况下，this 是缺省的。如函数fn()实际上是this->fn()。但是与普通函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指 针。从这个意义上讲，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，它只能调用其余的静态成员函数。 

### 实践推论
staitc 全局变量，不要定义在头文件当中，如果只想这个全局变量在本文件内使用的话，最好就把它放到实现文件cpp文件下。放在头文件的话，包含了该头文件的所有源文件中都定义了这些变量，即该头文件被包含了多少次，这些变量就定义了多少次。

也就是说，虽然都引用了同一个头文件，**但是他们用的根本不是同一个变量**，都是在源文件中被分别定义掉了。

虽然在代码中好像使用了相同的变量，但是实际上使用的是不同的变量，在每个源文件中都有单独的变量。所以，在头文件中定义static变量会造成变量多次定义，造成内存空间的浪费，而且也不是真正的全局变量。应该避免使用这种定义方式。

总结起来，static的关键作用： **隐藏作用、值保持**。

 - 隐藏作用。当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。如果加了static，就会对其它源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。Static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。

 - 保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

 - 默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加’\ 0’太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是’\0’。