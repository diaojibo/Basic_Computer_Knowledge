## c++ OOP基础
派生类必须通过使用类派生列表明确指出它是从哪个基类继承而来，基类前面可以有访问说明符。

``` c++
class B: public A{
};
```

### 动态绑定
跟java一样，当

```
A* b = new B();
```

当我们调用b的方法时，将会**采用动态绑定，也就是运行时绑定**，来决定当前类型调用哪个方法。如上，因为b其实是一个B类，所以将调用B类中的同名方法。

但是要注意，**只有使用指针或者引用才会调用动态绑定的方法**。

``` c++
B b;
A a;
a = b;
```

如上面代码，假如A是基类，此时用a调用A和B共有的某方法，最后这个方法还是会属于A，并不能触发动态绑定。因为a，b都不是指针或者引用变量，**类型静态编译时已经确定下来**，所以不会进行动态绑定。

#### virtual与动态绑定
**我们只有声明函数是虚函数，此时才会启用动态绑定**，定义虚函数也意味着我们想在派生类重写这个方法。如果成员函数**没有被定义为虚函数**，那么这个函数解析则会**发生在编译时**，不会动态绑定，所以要记住。


### 继承
派生类通过派生类列表来确定继承关系。

``` c++
class A : public B{

};
```

C++新标准允许派生类显示地注明将使用哪个函数改写基类的虚函数，具体措施是在函数的形参列表之后增加一个override关键字。

#### 成员函数的继承
**当我们希望成员函数被继承的时候，基类要将其定义为虚函数**。这样才能通过动态绑定，执行对应的方法。不注明virtual，只会发生静态绑定(解析发生在编译时)。

**带有没函数体的虚函数的类，可以通过编译，但是不能被初始化，这种也叫初级虚函数**
#### 派生类中的虚函数
一旦一个函数被设定成virtual，那么它在之后的所有派生类中都是virtual，所以之后也都没有必要显示设定virtual关键字

#### 纯虚函数和抽象基类
我们可以将函数 **定义成纯虚(pure virtual)来完成我们的设计意图**。

zwlj：pure virtual就类似于Java中的接口interface，用于设计，让子类继续完善方法。

在virtual函数后面书写=0即可定义一个虚函数为纯虚函数。

``` c++
Class A{
  virtual void Hello() const = 0;
};
```
不允许在类的内部给纯虚函数定义函数体，但是可以在类的外部定义。

**含有纯虚函数的基类是抽象基类。** 抽象基类就类似于Java里的抽象类，不能直接创建出来，


**注意普通虚函数也是可以没有实现的，带有没有实现的虚函数的类可以通过编译但是不能实例化。纯虚函数直接通过不为函数分配地址，达到组织初始化抽象类的目的**

#### 虚析构函数
当我们delete一个指针的时候，很有可能会发现要析构的对象并非指针所指的类型。比如基类指针A可能指向的是派生类B的实例。

我们只有在基类中定义析构函数为虚函数，才能触发动态绑定，使得虚构的过程正确无误的执行。delete对象时候，虚构函数会一层一层由派生类触发直至顶层基类。

原则上只要保证基类中定义的虚构函数是虚函数即可。

``` c++
class A{
  virtual ~A() = default;
};
```
