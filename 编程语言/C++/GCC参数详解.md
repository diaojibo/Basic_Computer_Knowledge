# gcc参数总结梳理
果然搞c++,肯定还是绕不开gcc的使用。gcc的各种参数，这里都进行一下记录梳理。

## -O 参数的优化
一般来说，如果不指定优化标识(**就是杠O参数**)的话，gcc就会产生可调试代码，每条指令之间将是独立的：可以在指令之间设置断点，使用gdb中的 p命令查看变量的值，改变变量的值等。并且把获取最快的编译速度作为它的目标。

当优化标识被启用之后，gcc编译器将会试图改变程序的结构（当然会在保证变换之后的程序与源程序语义等价的前提之下），以满足某些目标，如：代码大小最小或运行速度更快（只不过通常来说，这两个目标是矛盾的，二者不可兼得）。

#### -O，-O1
这两个命令的效果是一样的，目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。

#### -O2
该优化选项会**牺牲部分编译速度**，除了执行-O1所执行的所有优化之外，还会采用几乎所有的目标配置支持的优化算法，用以提高目标代码的运行速度。

#### -O3
该选项除了执行-O2所有的优化选项之外，一般都是采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等。

这个选项会提高执行代码的大小，当然会降低目标代码的执行时间。

#### -Os
这个优化标识和-O3有异曲同工之妙，当然两者的目标不一样，-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。

#### -Ofast
该选项将不会严格遵循语言标准，除了启用所有的-O3优化选项之外，也会针对某些语言启用部分优化。如：-ffast-math

#### -Og
该标识会精心挑选部分与-g选项不冲突的优化选项，当然就能提供合理的优化水平，同时产生较好的可调试信息和对语言标准的遵循程度。

## 动态库编译参数-fPIC(重)
现在来讲一讲经常在编译时用到的这个参数-fPIC

说到这个参数不得不提一提c++的静态库和动态库，当库被编译成动态库的时候，如果不加-fPIC参数，默认这个动态库地址是从0开始到xxxxxx，且不会有太多的符号相对地址信息，那我链接你的时候，就必须知道我要从哪个地方链接你，然后直接把你整一块都动态load进去。所以在每个进程在链接的时候，都要load这个so一份到自己的固定地址里。这样的话，每一个进程都需要load一份so到自己地址下，就不能高效复用这个动态库。

为了使内存中只存放一个这个动态库，而其他进程可以直接复用这一个动态库不用加载到自己进程里(为了不同调用都映射到同一块内存)。就必须加这个fPIC的参数来产生**位置无关代码(Position Independent Code)**,加了这个参数，这个动态库SO就会把一些地址无关代码放到GOT里，GOT属于可执行文件的数据段里的内容，用于重定位。

也就是说，如果不加fPIC，一般代码需要重定位某个函数的时候，要去把动态库加载一份到自己的进程了，也就是在内存里要多一份拷贝，这是通过修改动态库的执行地址来做到的。如果加了fPIC参数，就有办法通过动态库的GOT表，动态找到这些符号。多个进程可以复用一份内存中的动态库。

目前64位机器上编译动态库，都是会强制要求加-fPIC参数的了。**还有就是如果需要将一系列的静态库编译进so里，那将会要求这些静态库也用-fPIC编译过**。因为会需要用到位置无关代码，必须要求这些静态库也有。我们编写静态库一般不会加fPIC，因为如果有很多多余的GOT表的话，会扩大这个静态库的大小。

所以结论就是，当我们编译动态库时，基本上一定是会加-fPIC的，否则就不能实现真正的动态。当我们编译静态库时，我们就要考虑，这个静态库是编译到哪里去的，如果只是编译进一个静态可执行文件，那我们完全不需要这些PIC代码，会冗余。但如果我们要把这个静态库编进一个动态库里，那就需要用fPIC来编译了。