## const限定符

Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的**值是不能被更新的**。

const修饰符修饰的变量和引用类型的变量一样，**必须被初始化**，初始值**可以是复杂的表达式**。
.

### 编译时初始化

当我们定义

``` c++
const int buffSize = 512;
```

编译器将在编译过程中把用到该变量的地方都替换成对应的值512.


### extern const

const 修饰符默认只在**本文件内有效**。但是如若我希望在各个文件里都用，而且只在1个文件中初始化，我们就需要使用extern const 关键字。

``` c++

、、

// fiel1.cc
extern const int buffer = 512;

// file1.h
extern const int buffer;

```

以上两个文件中的变量定义略有不同。cc文件中，变量buffer进行了初始化，并且用extern声明了这个变量，这样方便外文件找到。h头文件中，声明了extern修饰符，说明这个变量不是在本文件中，需要从外面获取，所以并不需要在这儿赋初始值。

**因此只要在声明和定义，都用extern const，就能在多文件中使用常量。**


### 对常量的引用

可以把引用绑定到const 对象上，称之为对常量的引用。所以常量的引用依旧**不能修改所绑定的对象**。

比如

``` c++
const int ci = 1024;
const int &r1 = ci;
r1 = 42; //重新赋值会发生错误
int &r2 = ci; //错误，非常量指向常量
```


此外常量引用的初始化也往往处理的比较松，常量引用初始化时后面可接表达式，甚至**只要这个表达式可以类型转换成对应类型**都可以了。

``` c++
int i = 1;
const int &r1 = i; //right
const int &r2 = 42;//right
const int &r3 = r1 * 2; //right
int &r4 = r1 * 2;//wrong,r4理应是个别名

double dval = 3.14;
const int &ri = dval;
```

**常量引用原理其实就是编译器创建了一个临时变量来处理表达式。**

### 指针和const

#### 指向常量的指针(const在前)
指向常量的指针，定义时const在前，可以指向const，非const指针不能指向const类型。

同时，指向常量的指针初始化以后，也不可以通过它改变指向对象的实际值。

``` c++
const double pi = 3.14;
double *ptr = &pi; // wrong
const double *cptr=&pi; // right
*cptr = 42;//wrong
```

还要注意，指向常量的指针是个容易搞混的概念，**它是可以改变自身指向的对象的**，但它不能通过自己改变所指对象的值。

``` c++
double dval = 3.14;
double eval = 3;
const double *cptr = &dval;
cptr = &eval;//can do this
```

如上代码，我们可以随时改变指向常量的指针的值，而且**指向非const都完全没问题**。

**Tips：我们可以这样记，无论是指向常量的指针(const在前)，还是指向常量的引用(也只有const在前)，都只是一厢情愿的认为所指的对象是常量，所以自己不能通过自己去改变那个值，然而自己可以改变值。**

**指向常量的指针，定义时他只是定义自己是指向常量的一个变量而已。所以它自身可变**

#### const指针(const在后)
const指针也叫常量指针，因为指针是一个具体的类型，而常量不是，所以当然**允许指针自己被设定为常量**。

常量指针定义时，const放在类型后，且指针一旦设定后不可变。

``` c++
int errNumb = 0;
int *const curErr = &errNumb;
const double pi = 3;
const double *const pip = &pi;// 指向常量对象的常量指针
```

注意上面代码的第四句，比较有意思，是一个指向常量的常量指针，双不可变。

### constexpr和常量表达式
指值不会改变且编译过程中就能得到计算结果的常量表达式。

显然字面值就是一个常量表达式。用常量表达式初始化的const对象显然也是常量表达式。


### 用const修饰函数参数

经常我们可能会用const来修饰函数参数，比如

``` c
void fun(const int i);
```

用const修饰是有好处的，如果传递进的实参不是const类型，也会被转换为一个const类型的临时变量。如果不用const修饰

``` c
void fun(int i);

const a = 1;
fun(a);//error
```

const类型不能赋值给普通类型，所以这样就不能够调用。反之如果把形参设置为const，那就允许自动转换，且实参传入const也可以。

此外，如果const类型修饰的是指针或者引用。

``` c
void fun(const int* i);
```

那还可以防止指针i的内容被修改起到保护的作用。所以**既能防止原变量内容被修改(指针内容不能被修改，同时如果是引用形参，传入非const实参，还会创建临时变量起到保护原变量的作用)，还能使程序变得更健壮**。


### const用来修饰返回值(from effective c++)
记录几条effective c++里有关const是最佳实践。

返回值加const，也就是令函数返回一个常量值，**可以降低因客户错误而造成的意外，而不至于放弃安全性和高效性**

example，假设我们有一个乘号的运算符重载，返回一个对象：

![](image/const0.png)

如果上述代码不加const，就怕引起这样的暴行：

``` c++
Rational a,b,c;
(a * b) = c;
```

有可能知识打错从而出现这种情况，但是我们可以通过把返回值改为const，让这种情况被提前发现。**不过是多打6个字符**

### const成员函数
任何不会修改数据成员的函数都应该声明为const 类型，如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。

比如：
 
``` c++
 int GetCount(void) const; // const 成员函数  
```

**const 函数只能调用 const 函数，即使某个函数本质上没有修改任何数据，但没有声明为const，也是不能被const函数调用的。**