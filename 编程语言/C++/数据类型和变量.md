## 数据类型和变量

**机器字长**：是指计算机进行一次整数运算所能处理的二进制数据的位数（整数运算即定点整数运算）。机器字长也就是运算器进行定点数运算的字长，通常也是**CPU内部数据通路的宽度**。现在一般为32位即4个字节，也有64位和16位的。

C++定义了一套算术类型，和**空类型void**。算术类型的尺寸在不同机器上有区别。


算术类型的存储空间按照机器而定。一般，**short类型为半个机器字长，int为一个机器字长，long为1或2个机器字长**，float为一个机器字长，double为两个字，long double用3或4个字长。**C++标准规定的是每个算术类型的最小存储空间，但其并不阻止编译器用更大的存储空间**。如果要保证移植性，尽量用\_\_int16 \_\_int32 \_\_int64吧，或者自己typedef int INT32一下。

C++中规定了各种算术类型的最小尺寸：

 - bool 8bit
 - char 8bit
 - wchar_t 16bit
 - char16_t 16bit
 - char32_t 32bit
 - short 16bit
 - int 16bit
 - long 32bit
 - long long 32bit
 - float 6位有效数字
 - double 10位有效数字
 - long double 10位有效数字

一个char的空间应确保可以存放机器的基本字节字符集中的任意字符对应的数字值，即ASCII码中的任意字符，以前是7位，后面扩展为8位

C++中规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long则至少和一个long一样大，**其中，数据类型long long是在C++11中新定义的**。

除此之外，整形可以划分为带符号的(signed)和无符号的(unsigned),带符号的可以表示正负数，无符号的整形只会大于等于0.

但是与整形不同，字符型被分为3种：char,signed char和unsigned char.默认的char类型表现为有符号还是无符号的，完全由编译器决定。


选择类型使用遵循以下原则：

 - 明确为正数时使用无符号类型
 - 超过int范围时使用long long
 - 算术表达式避免使用char或者bool
 - 执行浮点运算应选择double

### 隐式类型转换

有以下规则

 - 非布尔值给bool，0为false，否则为true

 - 布尔值赋给非布尔，false为0，true为1

 - 浮点数赋值给整数，只保留整数位

 - **给一个无符号类型赋一个超出范围的值，结果是这个值对无符号类型表示数值总数取模后的余数**。比如-1赋值给unsigned char。则(-1) mod 256 = 255。得值为255(也可以用补码计算)。

 - 当我们给带符号类型一个超出类型表示范围的值得时候，结果是**未定义(undefined)的**。可能继续工作，可能崩溃，也可能生成垃圾数据。


### 变量声明和定义
变量可以声明和定义。**定义变量会申请存储空间，可能还会赋一个初始值**。

**函数外的变量初始化默认为0，块内变量默认不进行初始化，初始值是未定义的。**

C++支持分离式编译，假设我们想使用一个变量在多个文件中使用，那我们应该只定义它一次，然后在其他文件声明他来使用。这样编译时，找不到这个变量时才会出错。

``` c++
extern int i; // 声明i
int j; // 定义j
```

### 复合类型

#### 引用
引用为对象起了一个别名，通过\&d的形式定义引用类型，d是声明的变量名。**引用类型也必须被初始化，否则会报错。**

``` c++
int ival = 1024;
int &refival = ival;
```

定义引用时，程序把引用和它的初始值(上图的ival)绑定在一起，而且无法重新绑定。因此可以说，引用就是一个变量别名。

#### 指针
指针定义写成\*d, d是变量名。

想要获取某个对象或者说变量的地址，用\&(取地址)操作符，注意不要和定义引用时的\&符号搞混。

``` c++
int ival = 42;
int *p = &ival;
```

同时，\*是解引用符，用来获得指针所指向的对象,注意不要和定义指针时候的*符号搞混。

``` c++
int ival = 42;
int *p = &ival;
cout << *p;;
```
输出42。

还有一个需要注意的地方，**指针和引用的定义符号，都只作用一次**，经常会被带空格的写法误导

``` c++
int* p1,p2;
```
上面代码只有p1是指针，所以一般推荐符号跟变量挨在一起，否则就应该一个变量单独一行。

#### 指针的引用
这是一个经常让人搞混的概念，所以一定要万分注意。

``` c++
int *p;// p是一个指针
int *&r = p; // 一个引用，是指针p的引用(别名)
```

**这种写法是引用写在后，并且不存在指向引用的指针(也就是指针符号在后的情况)**

还有一个小技巧：观察变量时，**从变量名的定义，从右向左阅读，最近的符号是直接决定因素**。比如上面的代码最近的符号是引用定义，那么这就是一个引用。

#### 空指针
有以下几种方法可以初始化空指针：

``` c++
// c++11标准
int *p = nullptr;

int *p = 0;
// 这种方法需要先include cstdlib
int *p = NULL;
```

#### void*指针
特殊的指针类型，**可用于存放任意对象的地址**。

``` c++
double obj = 3.14;
void *pv = &obj;// right
```

void指针做的事情有限，我们只能拿他做比较，或者作为函数的输入和输出。**不能直接操作void\*指针所指的对象**

### auto类型
有时候我们定义变量，并将表达式值赋予的时候，也难以判段类型。这时候C++11允许我们定义变量为auto类型，让编译器去帮助我们分析表达式的值，并推算变量的类型。


auto类型，一定要有初始值。

``` c++
auto item = v1 + v2;//会根据v1和v2相加的类型推算出item的类型。

```
