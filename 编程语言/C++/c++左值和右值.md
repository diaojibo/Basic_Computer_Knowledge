## c++左值和右值

左值和右值在C中就存在，不過存在感不高，在C++尤其是C++11中這兩個概念比較重要

在 c 中，**左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)**，右值指的则是**只能出现在等号右边的变量或表达式**.右值是表达式结束之后就消失的**临时对象**。

``` c++
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a+b = 4;
```

通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值，如上的 3 + 4， a + b 等。我们暂且可以认为：**左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)**

但如上概念到了 c++ 中，就变得稍有不同。具体来说，在 c++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式"， "右值表达式"。对于基本数据类型来说(primitive types)，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，而且这种不同比较容易让人混淆.

**zwlj:总之就是可以理解为，左值就是可以取到地址的有名字的变量，而右值就是那些无法取到地址的临时变量**

有两个概念也必须理清楚：

 - **纯右值(prvalue, pure rvalue)**，纯粹的右值，要么是纯粹的字面量，例如 10, true；要么是求值结果相当于字面量或匿名临时对象，例如 1+2。**函数非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值**。
 - **将亡值(xvalue, expiring value)**，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。

例子：

``` c++
std::vector<int> foo() {
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;
}

std::vector<int> v = foo();
```

在这样的代码中，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，会将整个 temp 拷贝一份，然后把 temp 销毁，如果这个 temp 非常大，这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，v 是左值、foo() 返回的值就是右值（也是纯右值）。

但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一旦被 v 复制后，将立即被销毁，无法获取、也不能修改。

将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。

在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用綁定一個右值。但是實際上右值是可以被修改的，如 :

``` c++
T().set().get();
```

T是创建出的一个临时变量，通过set方法改变了内部的值。


### 左右值引用
左值的聲明符號為”\&”， 為了和左值區分，右值的聲明符號為”\&\&”。也就是说，左值引用就是普通的引用，右值引用是以个指向临时变量的引用。

右值引用，直觀意義：為臨時變量續命，也就是為右值續命，因為右值在表達式結束後就消亡了，如果想繼續使用右值，那就會動用昂貴的拷貝構造函數。

这里也要记住，两个引号\&\&算是C++ 11提出的一个新的引用类型。比如说`int&& x`是一个右值引用x，但是x本身又会算成是一个左值，要注意。

### std::move
std::move(t) 负责将表达式 t 转换为右值，使用这一转换意味着你不再关心 t 的内容，它可以通过被移动（窃取）来解决移动语意问题。

从实现上讲，std::move基本等同于一个类型转换：static_cast\<T\&\&\>(lvalue);

下面给出move函数一个应用，move可以减少临时变量的使用，提升效率。

``` c
template<class T>
void swap(T& a, T& b)
{
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}

```

上面是基于move操作实现的swap函数。

#### move语义(zwlj)

zwlj(move语义)： 现在我们知道了move函数的作用就是把左值转换为右值。那么为什么这么做了，其实就是为了减少一次拷贝。

就拿上面的swap函数做例子，我们中间都采用了std::move，那么假如Type T中重载了移动构造函数(参数是右值引用\&\&)，那赋值就会直接调用移动构造函数，从而降低了开销。因为一般，移动构造函数都会避免二次拷贝(表达式->临时变量结果->赋值给左值->销毁临时变量)，使变量直接获取临时变量的值，同时**移动构造函数还解决了对象内部资源拷贝的问题**，减少了很多开销。

总之注意一点，函数的非引用返回值是右值，类型其实是`&&`，而定义变量的时候，定义的变量就是左值。左右值传递给构造函数的行为是不同的，传递左值的时候类型是引用`&`会调用拷贝构造函数，传递右值则会调用移动构造函数

Reference:

<A>https://tw.saowen.com/a/6bcdd5a0b7d51dc8cda68ca33870f898d516b79c6cc80967c052d01bc48f746e</a>
