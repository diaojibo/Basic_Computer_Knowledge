## sizeof运算符
sizeof是C语言的一种**单目操作符**，如C语言的其他操作符++、--等。**它并不是函数**。sizeof操作符以**字节形式**给出了其操作数(也可能是对象的实例)的**存储大小**。

zwlj: 一定要注意sizeof不是函数而是一个单目运算符

**注意sizeof的返回值类型是一个size_t型，而size_t是这样定义的，typedef unsigned int size_t，也就是说它是一个unsigned int型。**

操作数可以是一个表达式或括在括号内的类型名。操作数的存储大小由操作数的类型决定。**sizeof不会实际计算对象的值。**

``` c++
sizeof(type)
sizeof(expr)
```

数据类型必须用括号括住。如sizeof（int）.变量名可以不用括号括住。如sizeof　(var_name)，sizeof　var_name等都是正确形式。带括号的用法更普遍，大多数程序员采用这种形式。　

sizeof采用右结合律，且不会实际计算对象的值，所以类似

``` c++
int *p;
sizeof(*p);
```

求得的是int类型的值，但是p却是个无效指针。因为根本没拿他来运算，**解一个未被初始化的无效指针在这里依然是安全行为**。

sizeof运算符的结果部分依赖于其作用类型

 - 对引用类型执行所得的是被引用对象所占空间大小
 - 对指针执行sizeof得到的是**指针本身所占空间大小**
 - 对数组sizeof得到整个数组所占空间的大小，等价于对数组中所有元素都sizeof求和。
 - 对string或者vector运算，返回的是该容器的固定大小，跟内部元素有多少无关。
 - sizeof **无法获取动态分配的内存大小**，即使用malloc动态的分配内存，无法使用sizeof获取其大小。
 - 注意c_style字符串末尾有一个\0结束符，也需要占一个char空间，因此sizeof("1") 返回2。

### 结构体的sizeof
理论上一个结构体所占空间是所有成员的大小总和，但由于考虑到对齐问题，会有填充字节。

``` c++
struct node
{
    int a;
    char c;
};
```

大小为8字节而不是5字节,填充了3字节。

注意：**c语言中空struct大小为0, 而c++中空struct 大小为1**, 具体看后面关于空类的讨论。

c99中结构体后面的动态数组，即不指定大小的数组，sizeof 时不包括动态数组的大小，即

``` c++
struct node
{
    int a;
    char c;
    int d[];
};
```

返回依然是8。

#### c++与c struct
首先说说c++ 中的struct类型，注意和c中的struct是不一样的，**c中的struct只是一种把各种基本数据类型包装的组合类型，而c++的struct本质上是类(重)**，即类有的东西，struct基本都有，**即struct也有构造函数、析构函数、成员函数等等**，不过它的默认成员是public的，而class定义的类成员默认是private的。

另外，struct继承默认也是public，而class定义的类默认是private。另外注意：class可以定义模板参数，但struct不可以！因此，struct本质就是类。

### 类的sizeof

类的空间占用有以下原则

1. **空类的大小**: 空类型实例中不包含任何信息，应该大小为0. 但是当我们声明该类型的实例的时候，**它必须在内存中占有一定的空间**，否则无法使用这些实例。至于占用多少内存，**由编译器决定**。**g++中每个空类型的实例占1字节空间**。注意空struct即空类，这就是为什么c++的空struct占一个字节的原因。

2. 构造函数、析构函数、成员函数调用时只需知道函数地址即可，而这些函数的地址之与类型相关，而**与具体的实例无关**，因此**不会在实例中额外添加任何信息**。

3. 静态数据成员放在全局数据成员中，它不占类实例大小，多个类实例只有一个实体。可以看作是一种特殊的全局变量。

由此可得

``` c++
class A
{
    public:
        static int a;
        static char c;
        A(){};
        ~A(){};
        void foo(){};
};
```

类A的大小为1字节，等于空类大小，因此静态数据成员a，c和成员函数都不占类的大小。

4. 类的非静态数据成员和c语言中的struct类似，**也需要对齐，可能需要字节填充**

``` c++
class A
{
    public:
        int a;
        char c;
        A(){};
        ~A(){};
        void foo(){};
};
```

类A的大小为8字节，a占4B，c占1B，填充3B。

5. 如果一个类中有虚函数，则该类型会生成一个虚函数表，并在该类型的每一个实例中添加一个指向虚函数表的指针，因此类大小必须加上一个指针所占的空间。如果是普通继承，子类和基类共享这个指针。


``` c++
class A
{
    public:
        int a;
        char c;
        A(){};
        ~A(){};
        void foo(){};
        void virtual bar(){};
};
```

类A的大小为12B。数据成员8B，加上指向虚拟函数表的指针。注意，是在32位系统上。如果是64位机器，一个指针占8B。

6. 虚继承时，派生类会生成一个指向虚基类表的指针，占一个指针大小空间。如果还有虚函数，不增加额外指针大小空间

``` c++
class A
{
    int a;
};
class B: public virtual A
{
    int b;
    virtual void foo(){};
};
```


类B的大小为12B，数据成员b占4B，从A中继承a也占4B，另外一个由于virtual存在，额外加一个指针大小4B，共12B。**所以(重)：只要有virtual，无论是在成员函数，还是在继承上，都额外加一个指针大小空间**。
