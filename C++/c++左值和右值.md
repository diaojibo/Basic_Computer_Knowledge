## c++左值和右值

左值和右值在C中就存在，不過存在感不高，在C++尤其是C++11中這兩個概念比較重要

在 c 中，**左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)**，右值指的则是**只能出现在等号右边的变量或表达式**.

``` c++
int a;
int b;

a = 3;
b = 4;
a = b;
b = a;

// 以下写法不合法。
3 = a;
a+b = 4;
```

通常来说有名字的变量就是左值(如上面例子中的 a, b)，而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值，如上的 3 + 4， a + b 等。我们暂且可以认为：**左值就是在程序中能够寻值的东西，右值就是没法取到它的地址的东西(不完全准确)**

但如上概念到了 c++ 中，就变得稍有不同。具体来说，在 c++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式"， "右值表达式"。对于基本数据类型来说(primitive types)，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，而且这种不同比较容易让人混淆.

**zwlj:总之就是可以理解为，左值就是可以取到地址的有名字的变量，而右值就是那些无法取到地址的临时变量**

在 C++11 之前，右值是不能被引用的，最大限度就是用常量引用綁定一個右值。但是實際上右值是可以被修改的，如 :

``` c++
T().set().get();
```

T是创建出的一个临时变量，通过set方法改变了内部的值。


### 左右值引用
左值的聲明符號為”\&”， 為了和左值區分，右值的聲明符號為”\&\&”。也就是说，左值引用就是普通的引用，右值引用是以个指向临时变量的引用。

右值引用，直觀意義：為臨時變量續命，也就是為右值續命，因為右值在表達式結束後就消亡了，如果想繼續使用右值，那就會動用昂貴的拷貝構造函數。

这里也要记住，两个引号\&\&算是C++ 11提出的一个新的引用类型。比如说`int&& x`是一个右值引用x，但是x本身又会算成是一个左值，要注意。

### std::move
std::move(t) 负责将表达式 t 转换为右值，使用这一转换意味着你不再关心 t 的内容，它可以通过被移动（窃取）来解决移动语意问题。

从实现上讲，std::move基本等同于一个类型转换：static_cast\<T\&\&\>(lvalue);

下面给出move函数一个应用，move可以减少临时变量的使用，提升效率。

``` c
template<class T>
void swap(T& a, T& b)
{
  T tmp(std::move(a));
  a = std::move(b);
  b = std::move(tmp);
}

```

上面是基于move操作实现的swap函数。

#### move语义(zwlj)

zwlj(move语义)： 现在我们知道了move函数的作用就是把左值转换为右值。那么为什么这么做了，其实就是为了减少一次拷贝。

就拿上面的swap函数做例子，我们中间都采用了std::move，那么假如Type T中重载了移动构造函数(参数是右值引用\&\&)，那赋值就会直接调用移动构造函数，从而降低了开销。因为一般，移动构造函数都会避免二次拷贝(表达式->临时变量结果->赋值给左值->销毁临时变量)，使变量直接获取临时变量的值，同时**移动构造函数还解决了对象内部资源拷贝的问题**，减少了很多开销。

Reference:

<A>https://tw.saowen.com/a/6bcdd5a0b7d51dc8cda68ca33870f898d516b79c6cc80967c052d01bc48f746e</a>
