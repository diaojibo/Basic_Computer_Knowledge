## const限定符

Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的**值是不能被更新的**。

const修饰符修饰的变量和引用类型的变量一样，**必须被初始化**，初始值**可以是复杂的表达式**。

### 编译时初始化

当我们定义

``` c++
const int buffSize = 512;
```

编译器将在编译过程中把用到该变量的地方都替换成对应的值512.


### extern const

const 修饰符默认只在**本文件内有效**。但是如若我希望在各个文件里都用，而且只在1个文件中初始化，我们就需要使用extern const 关键字。

``` c++

、、

// fiel1.cc
extern const int buffer = 512;

// file1.h
extern const int buffer;

```

以上两个文件中的变量定义略有不同。cc文件中，变量buffer进行了初始化，并且用extern声明了这个变量，这样方便外文件找到。h头文件中，声明了extern修饰符，说明这个变量不是在本文件中，需要从外面获取，所以并不需要在这儿赋初始值。

**因此只要在声明和定义，都用extern const，就能在多文件中使用常量。**


### 对常量的引用

可以把引用绑定到const 对象上，称之为对常量的引用。所以常量的引用依旧**不能修改所绑定的对象**。

比如

``` c++
const int ci = 1024;
const int &r1 = ci;
r1 = 42; //重新赋值会发生错误
int &r2 = ci; //错误，非常量指向常量
```


此外常量引用的初始化也往往处理的比较松，常量引用初始化时后面可接表达式，甚至**只要这个表达式可以类型转换成对应类型**都可以了。

``` c++
int i = 1;
const int &r1 = i; //right
const int &r2 = 42;//right
const int &r3 = r1 * 2; //right
int &r4 = r1 * 2;//wrong,r4理应是个别名

double dval = 3.14;
const int &ri = dval;
```

**常量引用原理其实就是编译器创建了一个临时变量来处理表达式。**

### 指针和const

#### 指向常量的指针(const在后)
指向常量的指针，定义时const在前，可以指向const，非const指针不能指向const类型。

同时，指向常量的指针初始化以后，也不可以拖过它改变指向对象的实际值。

``` c++
const double pi = 3.14;
double *ptr = &pi; // wrong
const double *cptr=&pi; // right
*cptr = 42;//wrong
```

还要注意，指向常量的指针是个容易搞混的概念，**它是可以改变自身指向的对象的**，但它不能通过自己改变所指对象的值。

``` c++
double dval = 3.14;
double eval = 3;
const double *cptr = &dval;
*cptr = &eval;//can do this
```

如上代码，我们可以随时改变指向常量的指针的值，而且**指向非const都完全没问题**。

**Tips：我们可以这样记，无论是指向常量的指针(const在前)，还是指向常量的引用(也只有const在前)，都只是一厢情愿的认为所指的对象是常量，所以自己不能通过自己去改变那个值，然而自己可以改变值。**

**指向常量的指针，定义时他只是定义自己是指向常量的一个变量而已。所以它自身可变**

#### const指针(const在后)
const指针也叫常量指针，因为指针是一个具体的类型，而常量不是，所以当然**允许指针自己被设定为常量**。

常量指针定义时，const放在类型后，且指针一旦设定后不可变。

``` c++
int errNumb = 0;
int *const curErr = &errNumb;
const double pi = 3;
const double *const pip = &pi;// 指向常量对象的常量指针
```

注意上面代码的第四句，比较有意思，是一个指向常量的常量指针，双不可变。

### constexpr和常量表达式
指值不会改变且编译过程中就能得到计算结果的常量表达式。

显然字面值就是一个常量表达式。用常量表达式初始化的const对象显然也是常量表达式。
