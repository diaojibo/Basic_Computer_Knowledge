## C++虚函数

C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。**所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法**。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

### 虚函数表
虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其内容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

  C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表时有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

假设我们有这样的一个类：

``` c++
class Base {
public:
  virtual void f() { cout << "Base::f" << endl; }
  virtual void g() { cout << "Base::g" << endl; }
  virtual void h() { cout << "Base::h" << endl; }
};
```

按照上面的说法，我们可以通过Base的实例来得到虚函数表。下面是实际例程：

``` c++
typedef void(*Fun)(void);
Base b;

Fun pFun = NULL;

cout << "虚函数表地址：" << (int*)(&b) << endl;                    # 强行把&b转成int*，取得虚函数表的地址
cout << "虚函数表 — 第一个函数地址：" << (int*)*(int*)(&b) << endl;  # 虚函数表的地址取值就可以得到第一个虚函数的地址

// Invoke the first virtual function
pFun = (Fun)*((int*)*(int*)(&b));
pFun();
```

以上吧b这个对象的地址取出，然后转换成了一个int指针。

实际运行经果如下：
```
(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)
      虚函数表地址：0012FED4
      虚函数表 — 第一个函数地址：0044F148
      Base::f
```

通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：

```
(Fun)*((int*)*(int*)(&b)+0); // Base::f()
(Fun)*((int*)*(int*)(&b)+1); // Base::g()
(Fun)*((int*)*(int*)(&b)+2); // Base::h()
```

让我画个图直观了解一下虚函数表。如下所示：

![](image/virtual0.jpg)

注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。


### 一般继承（子类无函数覆盖了基类的虚函数）
子类没有覆盖父类的虚函数是毫无意义的，之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其虚函数表的具体实现。

假设有如下所示的一个继承关系：

![](image/virtual1.jpg)

在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例d中，其虚函数表如下所示：

![](image/virtual2.jpg)

我们可以看到下面几点： **虚函数按照其声明顺序放于表中、父类的虚函数在子类的虚函数前面**。

### 一般继承（子类有函数覆盖了基类的虚函数）
子类覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？

假设，我们有下面这样的一个继承关系：

![](image/virtual3.jpg)

为了让大家看到被继承过后的效果，在这个类的设计中，只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：

![](image/virtual4.jpg)

我们从表中可以看到下面几点：子类的f()函数被放到了虚表中原来父类虚函数的位置、没有被覆盖的函数依旧。

这样，我们就可以看到对于下面这样的程序：

``` c++
Base *b = new Derive();
b->f();
```

 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。

### 多重继承（多个子类均无函数覆盖了基类的虚函数）
再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。

对于子类实例中的虚函数表，是下面这个样子：

![](image/virtual5.jpg)

我们可以看到：子类中每个基类都有自己的虚函数表、**子类的成员函数被放到了第一个基类的虚函数表中**。（所谓的第一个父类是按照声明顺序来判断的）

这样做就是**为了解决不同的基类类型的指针指向同一个子类实例的场景下，能够调用到实际的子类函数**。

### 多重继承（多个子类均有函数覆盖了基类的虚函数）
下面我们再来看看，如果发生虚函数覆盖的情况。下图中，我们在子类中覆盖了基类的f()函数。

![](image/virtual6.jpg)

下面是子类实例中的虚函数表的图：

![](image/virtual7.jpg)

我们可以看见，三个基类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以以任一静态类型的父类来指向子类，并调用子类的f()了。如：

``` c++
Derive d;
Base1 *b1 = &d;
Base2 *b2 = &d;
Base3 *b3 = &d;
b1->f(); //Derive::f()
b2->f(); //Derive::f()
b3->f(); //Derive::f()

b1->g(); //Base1::g()
b2->g(); //Base2::g()
b3->g(); //Base3::g()
```

### 虚函数和inline
函数的inline属性是在编译时确定的， 然而，virtual的性质则是在运行时确定的，这两个不能同时存在，只能有一个选择，文件中声明inline关键字只是对编译器的建议，编译器是否采纳是编译器的事情。

我并不否认虚函数也同样可以用inline来修饰，但你必须使用对象来调用，因为对象是没有所谓多态的，多态只面向行为或者方法，但是C++编译器，无法保证一个内联的虚函数只会被对象调用，所以一般来说，编译器将会忽略掉所有的虚函数的内联属性。

### 修饰构造与析构？
构造函数用来创建一个新的对象,而虚函数的运行是建立在对象的基础上,在构造函数执行时,对象尚未形成,所以**不能将构造函数定义为虚函数**。

通常析构函数才会用virtual修饰
