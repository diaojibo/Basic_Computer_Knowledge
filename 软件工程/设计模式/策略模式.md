## 策略模式
完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。

在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。

策略模式(Strategy Pattern)：**定义一系列算法，将每一个算法封装起来，并让它们可以相互替换**。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。

策略模式是一种对象行为型模式。

策略模式包含如下角色：

 - Context: 环境类
 - Strategy: 抽象策略类
 - ConcreteStrategy: 具体策略类

![](image/strategy0.jpg)

时序图如下：

![](image/strategy1.jpg)

简而言之就是，有一个环境类Context负责调用具体算法。然后我们生成不同的算法Strategy类，作为参数传递进Context负责执行。


以下是代码

``` c++
Strategy * s1 = new ConcreteStrategyA();
Context * cxt = new Context();
cxt->setStrategy(s1);
cxt->algorithm();

Strategy *s2 = new ConcreteStrategyB();
cxt->setStrategy(s2);
cxt->algorithm();
```

策略模式是**对算法的封装**，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是**准备一组算法，并将每一个算法封装起来，使得它们可以互换**。

#### 优点
 - 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
 - 策略模式提供了管理相关的算法族的办法。
 - 策略模式提供了可以替换继承关系的办法。
 - 使用策略模式可以避免使用多重条件转移语句。

#### 缺点
 - **客户端必须知道所有的策略类**，并自行决定使用哪一个策略类。
 - 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
