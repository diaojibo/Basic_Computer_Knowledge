## SQL注入
SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。

**而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入**，使攻击者成功的向服务器提交恶意的 SQL 查询代码

程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。

很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。

zwlj：被攻击者活用SQL注入可以实现很多事情

### SQL 注入原理
考虑以下简单的管理员登录表单：

``` html
<form action="/login" method="POST">
    <p>Username: <input type="text" name="username" /></p>
    <p>Password: <input type="password" name="password" /></p>
    <p><input type="submit" value="登陆" /></p>
</form>
```

后端的 SQL 语句可能是如下这样的：

``` sql
let querySQL = `
    SELECT *
    FROM user
    WHERE username='${username}'
    AND psw='${password}'
`;
// 接下来就是执行 sql 语句...
```

如果有一个恶意攻击者输入的用户名是 lct' OR 1 = 1 --，密码随意输入，就可以直接登入系统了。

恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：

```
SELECT * FROM user WHERE username='zoumiaojiang' OR 1 = 1 --' AND psw='xxxx'

```

这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为(在sql语句后面加各种东西)，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余

### 如何预防 SQL 注入
防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：

1. **严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害**

2. 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。

3. 对进入数据库的特殊字符（'，"，\\，<，\>，&，\*，; 等）**进行转义处理，或编码转换**。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash.\_escapehtmlchar 库。
**所有的查询语句建议使用数据库提供的参数化查询接口**，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即 **不要直接拼接 SQL 语句。例如 使用Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数**。

4. 在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，**例如 sqlmap、SQLninja 等**。

5. 避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。

6. 不要过于细化返回的错误信息，如果目的是方便调试，就去使用后端日志，**不要在接口上过多的暴露出错信息**，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。

根据安全规范：


 - 对于SQL注入，最稳妥和保险的方法 **只有使用预编译语句然后绑定变量**。通过使用占位符，**保持查询语句和数据相分离**。查询语句结构由占位符定义，SQL 语句发送给数据库并做好准备，然后准备好的语句与参数值相结合。这样就防止了查询被更改，因为参数值与已编译的语句相结合，而不是 SQL 字符串。从根本上避免了用户输入的恶意参数当作SQL语句执行。

 - 当实在是有like 、having、group by、order by 、limited 、offset等动态查询时才考虑白名单输入过滤、转义等方法。
