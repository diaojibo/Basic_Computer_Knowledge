## mysql索引类型

### MyISAM索引实现
MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是**数据记录的地址**。下图是MyISAM索引的原理图

![](image/mysql0.png)

MyISAM的索引方式也叫做“**非聚集**”的，之所以这么称呼是为了**与InnoDB的聚集索引区分**。


### InnoDB索引实现
虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。

第一个重大区别是**InnoDB的数据文件本身就是索引文件**。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就1主索引。

![](image/mysql1.png)

**可以看到叶节点包含了完整的数据记录**。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

**zwlj:MyIsam叶节点记录的是指针地址，而InnoDB则是记录了整个数据记录**

第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图为定义在Col3上的一个辅助索引：

![](image/mysql2.png)

这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，**例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大**。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，**非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整**，十分低效，而**使用自增字段作为主键则是一个很好的选择**。

### 单列索引和多列索引
如果查询语句使用索引（通常是where条件匹配索引)就会利用树的结构加快查找，索引会按值查找到要查找的行在表中位置，**不需回表查询数据的就是聚簇索引(索引和数据存放在一起)**。

通常是需要回表再查数据，需要消耗额外的磁盘IO。所以有些时候（如按顺序读取数据）全表扫描会比使用索引快的原因就在于此。

**单列索引：即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。**

**多列索引(组合索引)：即一个索引包含多个列。**

如果我们的查询where条件只有一个，我们完全可以用单列索引，这样的查询速度较快，索引也比较瘦身。如果我们的业务场景是需要经常查询多个组合列，不要试图分别基于单个列建立多个单列索引（因为虽然有多个单列索引，但是MySQL只能用到其中的那个它认为似乎最有效率的单列索引）。

当我们执行查询的时候，**MySQL只能使用一个索引**。如果你有三个单列的MySQL数据库索引，MySQL会**试图选择一个限制最严格的索引**。


#### 最左前缀匹配原则
mysql建立联合索引有最左前缀的原则，即最左优先：

 - 如果有一个2列的索引(col1, col2)，则已经对(col1)、(col1, col2)上建立了索引；

 - 如果有一个3列的索引(col1, col2, col3)，则已经对(col1)、(col1, col2)、(col1, col2, col3)上建立了索引；

b+树是按照**从左到右的顺序来建立搜索树的**，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道第一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。


zwlj：好比对于一个联合索引(userName,age)，我们写sql语句的时候就要写`where userName=X and age=Y` 而不太好写成`where age=Y and userName=X`，因为顺序必须匹配上(但是sql查询优化器会帮我们优化这个查询顺序)，先找到userName排序序列，再去找age排序序列。顺便一说对于上述多列索引，只用`where userName=X`，不写age也是可以用到这个索引的。
