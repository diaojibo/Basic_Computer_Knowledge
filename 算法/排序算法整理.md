## 排序算法

### 插入排序
将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表

**要点：设立哨兵，作为临时存储和判断数组边界之用。**

如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定**的。

``` c++
void print(int a[], int n ,int i){
    cout<<i <<":";
    for(int j= 0; j<8; j++){
        cout<<a[j] <<" ";
    }
    cout<<endl;
}


void InsertSort(int a[], int n)
{
    for(int i= 1; i<n; i++){   //从第二个元素开始
        if(a[i] < a[i-1]){              //先判断是否已经处于正确的位置
            int j= i-1;
            int x = a[i];        //复制为哨兵，即存储待排序元素，即是先把要排的元素抽出来，后面方便移动
            a[i] = a[i-1];           //先后移一个元素
            while(j>=0 && x < a[j]){  //查找在有序表的插入位置
                a[j+1] = a[j];
                j--;         //元素后移
            }
            a[j+1] = x;      //插入到正确位置
        }
        print(a,n,i);           //打印每趟排序的结果
    }

}

int main(){
    int a[8] = {3,1,5,7,2,4,9,6};
    InsertSort(a,8);
    print(a,8,8);
}

```


(自我实现)
``` c++
void InsertSort(int a[],int n){
	//插入排序为原地排序，前面是有序，后面是输入序列
	for(int i=1;i<n;i++){ //n是待排序数个数 ，1是原数组第二个元素，从第二个数开始
		int x = a[i];// 所谓的哨兵，就是把待排序数抽出来
		//插入排序这里是原地排序，所以数组分为两部分，前面的部分是已经排好序的，后面的序列是输入序列
		int j = i-1;// 从待排元素的前一个元素开始往前遍历
		while(j>=0&&a[j]>x){ //找正确的位置
			a[j+1] = a[j]; //如果不是正确的位置，就把所有元素往后移动一格
			j--; //往后遍历
		}
		a[j+1] = x; //找到了位置，把元素放到正确位置中
	}
}
```



### 选择排序
在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推

``` c++
int SelectMinKey(int a[], int n, int i)
{
    int k = i;
    for(int j=i+1 ;j< n; ++j) {
        if(a[k] > a[j]) k = j;
    }
    return k;
}

/**
 * 选择排序
 *
 */
void selectSort(int a[], int n){
    int key, tmp;
    for(int i = 0; i< n; ++i) {
        key = SelectMinKey(a, n,i);           //选择最小的元素
        if(key != i){
            tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换
        }
        print(a,  n , i);
    }
}

```


因为算法设计前后交换，会破坏顺序，所以是不稳定的。


### 冒泡排序
``` c++
void bubbleSort(int a[], int n){
    for(int i =0 ; i< n-1; ++i) {  //排序n-1次
        for(int j = 0; j < n-i-1; ++j) {  //从0开始交换没有排好序的数列
            if(a[j] > a[j+1])
            {
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;
            }
        }
    }
}
```

### 冒泡排序算法的改进

对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：

### 稳定性
冒泡排序，只要交换的条件不加等号。即a[j]>a[j+1]，则是稳定的排序。


### 归并排序
归并排序不用多说，是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。

**然而这里需要注意的是，归并算法有两种实现方式**

一种是普通二路归并排序，采用分治法。

另外一种是用迭代实现的归并排序(也可以说成是**自然归并排序**)。其思想是先相邻的元素两两合并，然后两个元素一组再两两合并，直到最后整个序列排好序。跟原来迭代自上而下的方法比，这种迭代的归并排序法是由下而上的。


实现:算法实现分为两个函数，一个是merge函数，这个函数挺重要的，接受三个参数，用来合并一个序列里的两个有序序列，接受一个mid值划分两边。至于mergesort函数，既可以用递归方式实现，也可以用迭代自下而上的方法实现。


(自我实现)

``` c++
void merge(int l,int mid,int r){
	//merge操作，很重要，把一个数列里[l,mid)和[mid,r]区域的元素排序，且由mid分开的位置都是排好序的序列

	vector<int> temp; //额外数组用来排序
	int i = l;
	int j =mid;
	while(i<mid&&j<=r){
		if(a[i]<a[j]) {
			temp.push_back(a[i]);
			i++;
		}
		else {
			temp.push_back(a[j]);
			j++;
		}
	}
	if(i<mid) for(int k=i;k<mid;k++) temp.push_back(a[k]);
	if(j<=r) for(int k=j;k<=r;k++) temp.push_back(a[k]);
	for(int i=l;i<=r;i++){
		a[i] = temp[i-l]; //排序完成后，放回原数列
	}
}


void mergeSort(int l,int r){
	//迭代的归并排序，自下而上

	int piece = 1; //一开始先定义合并的最小单位为1
	while(piece<n){ //结束条件，合并的长度大于等于整个序列则排好
		int p = 0;//从第一个元素开始合并

		while(p+piece<n){ //p+piece指的是当前合并块的下一个合并块的位置

			int mid = p+piece; //取mid为下一个合并块的位置

			if(mid+piece-1<n){ merge(p,mid,mid+piece-1);//如果下一个合并块数量足够，则merge操作 

			else merge(p,mid,n-1); //下一个合并块数量不足了，则直接取到最后一个元素
			p = mid + piece; //进行下两个合并块的合并
		}
		piece = piece * 2; //合并一轮走完，最小单位翻倍
	}
}
```

#### 稳定性
因为合并的时候前后顺序合并可以保持前面的序列优先，所以是稳定的。

#### 优化
当序列合并到后面时，可以采用插入排序优化。
