## 排序算法

### 插入排序
将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表

**要点：设立哨兵，作为临时存储和判断数组边界之用。**

如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定**的。

``` c++
void print(int a[], int n ,int i){  
    cout<<i <<":";  
    for(int j= 0; j<8; j++){  
        cout<<a[j] <<" ";  
    }  
    cout<<endl;  
}  
  
  
void InsertSort(int a[], int n)  
{  
    for(int i= 1; i<n; i++){   //从第二个元素开始
        if(a[i] < a[i-1]){              //先判断是否已经处于正确的位置
            int j= i-1;   
            int x = a[i];        //复制为哨兵，即存储待排序元素，即是先把要排的元素抽出来，后面方便移动  
            a[i] = a[i-1];           //先后移一个元素  
            while(j>=0 && x < a[j]){  //查找在有序表的插入位置  
                a[j+1] = a[j];  
                j--;         //元素后移  
            }  
            a[j+1] = x;      //插入到正确位置  
        }  
        print(a,n,i);           //打印每趟排序的结果  
    }  
      
}  
  
int main(){  
    int a[8] = {3,1,5,7,2,4,9,6};  
    InsertSort(a,8);  
    print(a,8,8);  
}  

```


(自我实现)
``` c++
void InsertSort(int a[],int n){
	//插入排序为原地排序，前面是有序，后面是输入序列 
	for(int i=1;i<n;i++){ //n是待排序数个数 ，1是原数组第二个元素，从第二个数开始 
		int x = a[i];// 所谓的哨兵，就是把待排序数抽出来 
		//插入排序这里是原地排序，所以数组分为两部分，前面的部分是已经排好序的，后面的序列是输入序列 
		int j = i-1;// 从待排元素的前一个元素开始往前遍历 
		while(j>=0&&a[j]>x){ //找正确的位置 
			a[j+1] = a[j]; //如果不是正确的位置，就把所有元素往后移动一格 
			j--; //往后遍历 
		}
		a[j+1] = x; //找到了位置，把元素放到正确位置中 
	}
}
```



### 选择排序
在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推

``` c++
int SelectMinKey(int a[], int n, int i)  
{  
    int k = i;  
    for(int j=i+1 ;j< n; ++j) {  
        if(a[k] > a[j]) k = j;  
    }  
    return k;  
}  
  
/** 
 * 选择排序 
 * 
 */  
void selectSort(int a[], int n){  
    int key, tmp;  
    for(int i = 0; i< n; ++i) {  
        key = SelectMinKey(a, n,i);           //选择最小的元素  
        if(key != i){  
            tmp = a[i];  a[i] = a[key]; a[key] = tmp; //最小元素与第i位置元素互换  
        }  
        print(a,  n , i);  
    }  
}  

```


因为算法设计前后交换，会破坏顺序，所以是不稳定的。


### 冒泡排序
``` c++
void bubbleSort(int a[], int n){  
    for(int i =0 ; i< n-1; ++i) {  //排序n-1次
        for(int j = 0; j < n-i-1; ++j) {  //从0开始交换没有排好序的数列
            if(a[j] > a[j+1])  
            {  
                int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;  
            }  
        }  
    }  
}  
```

### 冒泡排序算法的改进

对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。本文再提供以下两种改进算法：

### 稳定性
冒泡排序，只要交换的条件不加等号。即a[j]>a[j+1]，则是稳定的排序。