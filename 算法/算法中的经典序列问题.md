## 序列问题

### 最大子序列和

就是给定一个数的序列，求子序列最大和。

最常规的当然是N^3的解法，前缀和可以优化到n^2.但是最常规的还是动态规划的标准解法。

动规公式可以这样写，**f(i)=max(f(i-1)+a[i],a[i])**

注意这个公式f(i)代表以a[i]元素结尾的序列的最大和，所以动态规划一遍之后，再扫一遍取最大值就可以了，甚至可以一边动规一边求最大值。思想主要是这样，然而主流优化之后，写出来的代码**反倒有点像贪心**

我们来看看标准解法：
``` c++
//线性的算法O(N) 
long maxSubSum4(const vector<int>& a) 
{ 
       long maxSum = 0, thisSum = 0; 
       for (int j = 0; j < a.size(); j++) 
       { 
              thisSum += a[j]; //每回合直接记录序列和
              if (thisSum > maxSum) 
                     maxSum = thisSum; //这里跟动规公式相比直接就进行更新，省去了最后再扫一遍的步骤
              else if (thisSum < 0) 
                     thisSum = 0; 
//这里是优化的最厉害的地方，每当我们的序列和成为了负数，说明这一段序列和不可能再继续使用了，只能重新开一断序列。所以从0开始，说明这段已经成为负数的序列抛弃完全不用
       } 
       return maxSum; 
}

```

然后最后假定遇到全部负数的情况，直接取0即可。上面的算法很记忆化，一边求解一边记录。


### 最长递增序列
*给定一个长度为N的数组，找出一个最长的单调自增子序列（不一定连续，但是顺序不能乱）。例如：给定一个长度为6的数组A{5， 6， 7， 1， 2， 8}，则其最长的单调递增子序列为{5，6，7，8}，长度为4.*

**这个问题的标准解法是n^2的**，利用动规，没遍历一个数就往前找，动规方程为 **f[i]=max(f[j]+1)（j<i and a[j]<a[i]）**

**然而确实是存在一种算法能达到O(nlogn)的复杂度。**

这里就介绍一下那个算法，首先只需要维护一个数组B

B[i]维护的是，这个序列中现找到的长度为i的所有递增序列中末尾最大值的最小值。

不太好理解，意思就是，在遍历原序列找递增序列的过程中，B[i]代表的就是现在找到了这么个i长度的递增序列里面，递增序列最后一个值最小的放到B[i]里。

有这个B[i]序列，那我们就能通过维护B[i]找出最长的序列数，但要注意，仅仅通过这个方法也不能求出这个最长递增序列，只能求出最长递增序列的长度。

详细过程从网上抄来方便理解：

假设存在一个序列d[1..9] = 2 1 5 3 6 4 8 9 7，可以看出来它的LIS长度为5。下面一步一步试着找出它。

我们定义一个序列B，然后令 i = 1 to 9 逐个考察d这个序列。
此外，我们用一个变量Len来记录现在最长算到多少了

首先，把d[1]有序地放到B里，令B[1] = 2，就是说当只有d1这一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1

然后，把d[2]=1有序地放到B里，令B[1] = 1，就是说长度为1的LIS的最小末尾是1，d[1]=2已经没用了(因为有个长度为1的序列，末尾是1，最小)，很容易理解吧。这时Len=1

接着，d[3] = 5，d[3]>B[1]，所以令B[1+1]=B[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2

再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2

继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。

第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3

第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了

第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。

最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。

于是我们知道了LIS的长度为5。


### 最长公共子串
**最长公共子串(Longest Common Substring)**
这也是经典问题了，求两个字符串x,y的最长公共子串

直接写公式即可

f[i][j]代表的是x串前i个字符和y串前j个字符的最长公共子串。则可以写出公式:若x[i]=y[j]根据连续性，f[i][j]=f[i-1][j-1]+1.如果x[i]!=y[j].说明子串在这里就断了，因此f[i][j]=0.

最后答案就是f[i][j]

### 最长公共子序列
实质上就是LCS最长公共子串的变形。

公式有所改变
若x[i]=y[j]根据序列的间断性，f[i][j]=max(f[i-1][j],f[i][j-1],f[i-1][j-1]+1).如果x[i]!=y[j]。子序列在这里并没断所以f[i][j]=max(f[i-1][j],f[i][j-1])