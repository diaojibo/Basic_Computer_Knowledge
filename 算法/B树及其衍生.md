## B树
B树（英语：B-tree）B即Balanced，是一种自平衡的树，能够保持数据有序。概括来说是一个
**一般化的二叉查找树（binary search tree）**，可以拥有多于2个子节点。

**注意b-树就是b树**

但是我们要面对这样一个实际问题，大规模数据存储中，实现索引查询是在这样一个实际背景下的，即树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，那么如何减少树的深度，一个基本的想法就是：**采用多叉树结构**。

在大规模数据存储方面，**大量数据存储在外存磁盘中**，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构

### b-树
**注意b-树就是b树**，-不是减号，是英文里的连字符号。也又可以认为b树是b-树和b+树的统称。

B 树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树

那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作

如下图所示，即是一棵B树，一棵关键字为英语中辅音字母的B树，现在要从树种查找字母R（包含n[x]个关键字的内结点x，x有n[x]+1]个子女（也就是说，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女）。所有的叶结点都处于相同的深度，带阴影的结点为查找字母R时要检查的结点）：

![](image/b-tree.jpg)
从上图能轻易的看到，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女。如含有2个关键字D H的内结点有3个子女，而含有3个关键字Q T X的内结点有4个子女。

一棵m阶的B树满足下列条件：

 1. 树中每个结点至多有m个孩子；
 2. 除根结点和叶子结点外，其它每个结点至少有m/2(向上取整)个孩子；
 3. 若根结点不是叶子结点，则至少有2个孩子；
 4. 所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息；
 5. 有k个孩子的非终端结点恰好包含有k-1个关键字。

B树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，**该k-1个关键字正好是k个孩子包含的关键字的值域的分划**。

也就是说每个节点刚好利用k个关键字把值域分成k+1份，每一份又可以递归下去成为一个子节点域。

![](image/b-tree2.jpg)
如图，比如我要找28这个节点。

我们会先从根节点的关键字里面开始找，关键字已经排好序，在关键字里二分查找，发现没有28。那么我们发现28在17和35中间，到p2对应的中间值域子节点里去找。二分查找后发现还是没有，那就继续进入到叶子结点里，最后找到28.

B-树的特性：

 1. 关键字集合分布在整颗树中；
 2. 任何一个关键字出现且只出现在一个结点中；
 3. 搜索有可能在非叶子结点结束；
 4. **其搜索性能等价于在关键字全集内做一次二分查找**
 5. 自动层次控制；

#### b-树的插入
![](image/b-tree4.gif)

6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4

总结起来，规律便是

首先是在恰当的叶子结点中添加关键码，如果该结点中关键码不超过m-1个，则插入成功。否则要把这个结点分裂为两个。并把中间的一个关键码拿出来插到结点的父结点里去。父结点也可能是满的，就需要再分裂，再往上插。最坏的情况，这个过程可能一直传到根，如果需要分裂根，由于根是没有父结点的，这时就**建立一个新的根结点**。插入可能导致B树朝着根的方向生长。

#### b-树的删除

在B-树上删除关键字k的过程分两步完成：

 1. 利用前述的B-树的查找算法找出该关键字所在的结点。然后根据 k所在结点是否为叶子结点有不同的处理方法。
 2. 若该结点为非叶结点，且被删关键字为该结点中第i个关键字key[i]，则可从指针son[i]所指的子树中找出最小关键字Y，代替key[i]的位置，然后在叶结点中删去Y(找被删节点下的最小节点)。

因此，把在非叶结点删除关键字k的问题就变成了删除叶子结点中的关键字的问题了。

调整过程为：用图来解释吧

**1. 被删关键字Ki所在结点的关键字数目不小于ceil(m/2)，则只需从结点中删除Ki和相应指针Ai，树的其它部分不变。**
![](image/btree5.png)

 **2. 被删关键字Ki所在结点的关键字数目等于ceil(m/2)-1，则需调整。调整过程将右（左）兄弟结点中最小（大）关键字上移至双亲结点。而将双亲结点中小（大）于该上移关键字的关键字下移至被删关键字所在结点中。**
![](image/btree6.png)

**3. 被删关键字Ki所在结点和其相邻兄弟结点中的的关键字数目均等于ceil(m/2)-1，假设该结点有右兄弟，且其右兄弟结点地址由其双亲结点指针Ai所指。则在删除关键字之后，它所在结点的剩余关键字和指针，加上双亲结点中的关键字Ki一起，合并到Ai所指兄弟结点中（若无右兄弟，则合并到左兄弟结点中）。如果因此使双亲结点中的关键字数目少于ceil(m/2)-1，则依次类推**

![](image/btree7.png)


## b+树
B+树是B-树的变体，也是一种多路搜索树，它与B树的差异在于：

- 有k个子结点的结点必然有k个关键码；
- 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树。（B-树是开区间）
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

如图
![](image/btree9.jpg)

B+的搜索与B-树也基本相同，区别是B+树只有**达到叶子结点才命中**（B-树可以在

非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；


#### b+树对比b树优点
- B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。

- B+树的查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

总之需要注意的便是，b+树的内节点不存储真正的数据，所以一次可以把更多的节点保存到内存当中方便查找(比如把根节点和前几层频繁要读入的节点保存在内存中，不用每次都去磁盘寻道)。磁盘寻道的时间是最长的，所以我们想要减少寻道的时间，就要尽量多的把节点(b+树里只用于索引)保存下内存中，因为b树的非叶子节点里还包含有很多真正的节点信息，所以装载到内存需要的空间就更大，而b+树只有叶子节点才是真正的节点，其他节点用于索引，所以放到内存里查找时更高效。


## b*树
是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

![](image/btree10.jpg)

B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3

（代替B+树的1/2）；

所以，B*树分配新结点的概率比B+树要低，空间使用率更高(因为每个节点要存储的信息变多了一些，二分之一变成三分之二了)；

## 小总结
三树其实性能相当，都等价于在关键字全集做一次二分查找；

- B+树比 B-树 更适合文件索引系统(结构上的改善[所有关键信息都在叶子节点，使得非叶节点的空间变小])，
- B*树比B+树改善了空间利用率(每个节点存储的关键字变多了)。


