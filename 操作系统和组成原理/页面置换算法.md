## 页面置换算法
在存储管理笔记中，我们知道了分页技术。

地址映射过程中，若在页面中发现所要访问的页面不再内存中，则产生缺页中断。当发生缺页中断时操作系统必须**在内存选择一个页面将其移出内存**，以便为即将调入的页面让出空间。而**用来选择淘汰哪一页的规则叫做页面置换算法**。

### 最佳置换算法（OPT）（理想置换算法）
这是一种理想情况下的页面置换算法，但**实际上是不可能实现的**。

该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，**每个页面都可以用该页面首次被访问前所要执行的指令数进行标记**。最佳页面置换算法只是简单地规定：**标记最大的页应该被置换**。

zwlj：也就是，越久用到的页面先被置换出去。

这个算法**唯一的一个问题就是它无法实现**。当缺页发生时，**操作系统无法知道各个页面下一次是在什么时候被访问**。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。

### 先进先出置换算法（FIFO）
最简单的页面置换算法是先入先出（FIFO）法。这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存

理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。

这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些**常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去**。

FIFO的另一个缺点是，它有一种异常现象，即在**增加存储块的情况下，反而使缺页中断率增加了**。当然，导致这种异常现象的页面走向实际上是很少见的。

### 最近最久未使用（LRU）算法
它的实质是，当需要置换一页时，选择在**最近一段时间里最久没有使用过的页面予以置换**。这种算法就称为最久未使用算法（Least Recently Used，LRU）。

LRU算法是经常采用的页面置换算法，**并被认为是相当好的**，但是存在如何实现它的问题。LRU算法需要**实际硬件的支持**。

其问题是怎么确定最后使用时间的顺序，对此有两种可行的办法：

1. 计数器。最简单的情况是使每个页表项对应一个使用时间字段，并给CPU增加一个逻辑时钟或计数器。每次存储访问，该时钟都加1。每当访问一个页面时，时钟寄存器的内容就被复制到相应页表项的使用时间字段中。这样我们就可以始终保留着每个页面最后访问的“时间”。在置换页面时，选择该时间值最小的页面。这样做，不仅要查页表，而且当页表改变时（因CPU调度）要维护这个页表中的时间，还要考虑到时钟值溢出的问题。

2. 栈(还用了双向链表)。用一个栈保留页号。**每当访问一个页面时，就把它从栈中取出放在栈顶上**。这样一来，栈顶总是放有目前使用最多的页，而栈底放着目前最少使用的页。由于要从栈的中间移走一项，所以**要用具有头尾指针的双向链连起来**。在最坏的情况下，移走一页并把它放在栈顶上需要改动6个指针。每次修改都要有开销，但需要置换哪个页面却可直接得到，用不着查找，因为尾指针指向栈底，其中有被置换页。

因实现LRU算法必须有大量硬件支持，还需要一定的软件开销。所以**实际实现的都是一种简单有效的LRU近似算法**。

### 最近未使用算法（Not Recently Used，NUR）
它在存储分块表的每一表项中增加一个引用位，**操作系统定期地将它们置为0**。当某一页被访问时，由**硬件将该位置1**。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0后还未使用过。就可把该位是0的页淘汰出去，因为在最近一段时间里它未被访问过。

### LFU置换算法
最少使用置换算法，选择在最近**时期使用最少的页面**作为淘汰页。

LFU（Least Frequently Used）：内存内使用越频繁的页面，被保留的时间也相对越长。

zwlj：要注意LRU和LFU的区别，LRU的重点是时间，最长时间没有使用的先被移除。而LFU重点是一段时间内，最少使用次数的先被移除。
