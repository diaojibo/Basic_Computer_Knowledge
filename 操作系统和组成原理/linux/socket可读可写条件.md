## socket可读可写条件

要了解socket可读可写条件，我们先了解几个概念：

### 缓存区低水位
接收缓存区低水位标记（用于读）和发送缓存区低水位标记（用于写）

每个套接字有一个接收低水位和一个发送低水位。他们由**select函数**使用。

接收低水位标记是让**select返回"可读"时套接字接收缓冲区中所需的数据量**。对于TCP,其**默认值为1**。

发送低水位标记是让select返回"可写"时套接字发送缓冲区中所需的可用空间。对于TCP，其**默认值常为2048**.

通俗的解释一下，缓存区我们当成一个大小为 n bytes的空间，那么：

接收区缓存的作用就是，接收对面的数据放在缓存区，供应用程序读。当然了，只有当缓存区可读的数据量(接收低水位标记)到达一定程度（eg:1）的时候，我们才能读到数据，不然不就读不到数据了吗。
发送区缓存的作用就是，发送应用程序的数据到缓存区，然后一起发给对面。当然了，只有当缓存区剩余一定空间(发送低水位标记)（eg:2048）,你才能写数据进去，**不然可能导致空间不够**。

### FIN: (结束标志,Finish)
FIN: (结束标志,Finish)用来结束一个TCP回话.但对应端口仍处于开放状态,准备接收后续数据.

### socket可读的条件
1. socket的接收缓冲区中的数据字节大于等于该socket的接收缓冲区低水位标记的当前大小。对这样的socket的读操作**将不阻塞**并 **返回一个大于0的值(也就是返回准备好读入的数据)**。我们可以用SO_RCVLOWAT socket选项来设置该socket的低水位标记。对于**TCP和UDP .socket而言，其缺省值为1**.

2. 该连接的读这一半关闭(也就是**接收了FIN的TCP连接**)。对这样的socket的读操作将**不阻塞并返回0**

3. socket是一个用于监听(listen)的socket,并且已经完成的连接数为非0.这样的soocket处于可读状态,是因为socket**收到了对方的connect请求**,执行了三次握手的第一步:对方发送SYN请求过来,使监听socket处于可读状态;正常情况下,**这样的socket上的accept操作不会阻塞**;

4. 有一个socket有**异常错误条件待处理**.对于这样的socket的读操作**将不会阻塞**,并且 **返回一个错误(-1)**,errno则设置成明确的错误条件.这些待处理的错误也可通过指定socket选项SO_ERROR调用getsockopt来取得并清除;

### 套接字可写条件
1. 该套接字发送缓冲区中的可用空间字节数大于等于套接字发送缓存区低水位标记时，并且该套接字已经成功连接（UDP套接字不需要连接）。对于TCP和UDP而言，这个低水位的值默认为2048，而**套接字默认的发送缓冲区大小是8k**，这就意味着一般一个套接字连接成功后，就是处于可写状态的。我们可以通过SO_SNDLOWAT套接字选项（参见setsockopt函数）来**设置这个低水位**。此种情况下，我们设置该套接字为非阻塞，**对该套接字进行写操作(如write,send等)，将不阻塞**，并**返回一个正值**（例如由传输层接受的字节数，即发送的数据大小）。

2. 该连接的写半部关闭。对这样的套接字的写操作将会产生SIGPIPE信号。所以我们的网络程序基本都要自定义处理SIGPIPE信号。因为SIGPIPE信号的默认处理方式是程序退出。

3. **使用非阻塞的connect套接字已建立连接**，或者connect已经以失败告终。即**connect有结果了**。

4. 有一个错误的套接字待处理。对这样的套接字的写操作将不阻塞并返回-1（也就是返回了一个错误），同时把errno设置成确切的错误条件。这些待处理的错误也可以通过指定SO_ERROR套接字选项调用getsockopt获取并清除。
