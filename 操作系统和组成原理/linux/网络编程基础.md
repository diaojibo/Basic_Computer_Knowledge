# 网络编程基础

## 基本接口
Linux下，有一些基本的网络编程接口。

 - socket(), 创建Socket描述符，以供其他接口调用。
 - bind(): 通过socket接口创建的Socket描述符只存在于其协议簇空间，bind用来将一组固定的地址绑定到Socket描述符上。
 - listen():监听某个socket接口。
 - accept() 服务器方面，由内核产生一个Socket描述符用来，用来和TCP对端进行连接。
 - recv():接受对端发送的数据，从接收缓冲区复制数据。
 - connect() 创建与TCP服务器之间的Socket连接
 - send() 向对端发送数据，操作系统内核会将用户数据复制到**TCP套接字的发送缓冲区**，然后发送出去。

### 非阻塞的服务器程序
在常规的listen-accept模式下，基本都是阻塞blocked的。

**一个非常可用的方案是配合多线程+线程池管理来进行socket连接。**但是显然，这不能解决所有问题，创建多余的线程也会给系统带来压力。

参考操作系统部分，5种IO模型笔记，我们知道IO有非阻塞的方法。

非阻塞接口的特点就是，被调用以后立即返回，使用如下函数可以将某句柄fd(文件描述符)设为非阻塞状态。

`fcntl(fd,F_SETFL,O_NONBLOCK)`

启用了这个函数以后，`recv()`接口在调用完成后会立即返回一个值：

1. recv()返回0，连接已经断开
2. recv()返回值大于0，接收数据完毕，且返回值是接受到的字节数
2. recv()返回-1,且errno不等于EAGAIN，操作遇到系统错误errno
3.recv()返回-1且erroo等于EAGAIN，操作还没完成。


如此一来，我们便可以用轮询的方式(对应5种IO模型中的第二种)，循环调用recv，但是这种方法会大幅度提高CPU占用率。所以操作系统为我们提供了更好的借口select()

### 基于select()接口的事件驱动服务器模型
大部分Linux函数都支持select函数，根据5种IO模型的笔记，当我们调用select函数时，线程自身会被阻塞，然后操作系统内核会替代我们轮询各个connection，探测文件句柄的状态变化。这也就是笔记中的**IO复用模型**

当我们同时要处理多个套接字的时候，也必须要使用IO复用。

下面是select接口的原型：

``` c++
FD_ZERO(int fd, fd_set* fds);
FD_SET(int fd,fd_set* fds);
FD_ISSET(int fd,fd_set* fds);
FD_CLR(int fd,fd_set* fds);
int select(int nfds,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)
```


这里，fd_set可以简单地理解为按bit位标记句柄的标记数组，例如在fd_set中标记一个值为16的句柄，则fd_set的第16个bit位被标记为1.(zwlj：实际上就是用位运算优化标记数组)


所以调用select函数，相当于传递进去几个标记数组，如果readfs中标记了16号句柄，那select将会检测(内核轮询)16号句柄是否可读。在select返回后，可以检查readfs来判断可读事件是否发生(数据是否复制到内核了)，如果可读，将会调用recv复制数据(此时recv一定能读到数据)。此外，用户还可以设置timeout时间。

FD_SET用来设置句柄的标记，FD_ISSET用来检查哪些句柄发生了事件(zwlj：哪些文件描述符指向的内存区域已经准备好读写数据了)

一下看select使用范例：

``` c
//str_cli
void
str_cli(FILE *fp, int sockfd)
{
    int         maxfdp1;
    fd_set      rset;
    char        sendline[MAXLINE], recvline[MAXLINE];

    FD_ZERO(&rset);
    for ( ; ; ) {
        FD_SET(fileno(fp), &rset);
        FD_SET(sockfd, &rset);
        maxfdp1 = max(fileno(fp), sockfd) + 1;
        Select(maxfdp1, &rset, NULL, NULL, NULL);

        if (FD_ISSET(sockfd, &rset)) {  /* socket is readable */
            if (Readline(sockfd, recvline, MAXLINE) == 0)
                err_quit("str_cli: server terminated prematurely");
            Fputs(recvline, stdout);
        }

        if (FD_ISSET(fileno(fp), &rset)) {  /* input is readable */
            if (Fgets(sendline, MAXLINE, fp) == NULL)
                return;     /* all done */
            Writen(sockfd, sendline, strlen(sendline));
        }
    }
}
```

如上代码，定义了一个函数str_cli，接受一个文件指针，和一个socket 文件描述符，根据Unix一切皆文件的思想，我们只要拿到文件描述符，就可以去读写文件描述符指向的内存，即IO.所以我们看到下面代码，先用FD_ZERO将标记数组清零，然后用一个永久循环，每次循环在rset结构中标记要读取的fd，然后用select去让操作系统轮询，一旦发现有地方可以读，就解开阻塞，交给下面的if语句去读取。
