## Linux进程调度
进程提供了**两种优先级**，一种是**普通的进程优先级**，第二个是**实时优先级**。前者适用**SCHED_NORMAL**调度策略，后者可选**SCHED_FIFO或SCHED_RR**调度策略。任何时候，**实时进程的优先级都高于普通进程**，实时进程只会被更高级的实时进程抢占，**同级实时进程之间是按照FIFO（一次机会做完）或者RR（多次轮转）规则调度的**。

### 进程优先级

每个非实时进程(普通进程)都有自己的静态优先级（nice值），值越大优先级越低。。nice值是所有Unix系统的标准化概念，在OS X系统中nice值代表分配给进程的时间片的绝对值，而Linux中代表时间片的比例。通过ps -el命令查看系统中的进程列表，结果中标记NI的一列就是进程对应的nice值。

对于实时进程，实时优先级的范围是从1（最低优先级）~ 99（最高优先级），含义与nice值相反。任何实时进程的优先级总高于非实时进程（普通进程）。你可以通过ps -eo stata,uid,pid,ppid,rtprio,time,com查看系统中的进程列表，在RTPRIO列的就是实时优先级，如果显示-，则该进程不是实时进程。

### 时间片
时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。一般来说，调度策略必须规定一个默认的时间片，但是Linux的CFS调度器并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程。这样一来，进程所获得的处理器时间其实是和系统负载密切相关的。nice值作为权重将调整使用比，值越大，使用比越小。Linux中CFS调度器的抢占时机取决于新进程所消耗的使用比。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率置于不断变动中。

不过，当可运行进程的数量区域无限时，每个进程获得使用比则趋于0，岂不是时间都花在切换进程上了？CFS为此引入了每个进程获得的时间片最小粒度，默认是1ms,也就是每个进程最少能获得1ms的运行时间。

### 调度类型
每个Linux进程都按照以下调度类型被调度：

 - SCHED_FIFO 先进先出的实时进程。**如果没有优先级更高的可运行的实时进程，则当前运行的实时进程想运行多久便运行多久**，即使还有其他优先级相同的可运行实时进程

 - SCHED_RR(round robin) 时间片轮转的实时进程。保证对所有相同优先级的实时进程公平地分配CPU时间。

 - SCHED_NORMAL 普通的分时进程。

### 调度算法
如今Linux采用的算法为“**完全公平调度算法**”，简称CFS。CFS是一个针对普通进程的调度器，期调度类型为SCHED_NORMAL。在时间片中已经讲到，nice值在CFS中被作为进程获得处理器运行比的权重。

CFS使用一个struct sched_entity数据结构来记录进程的调度情况，包括运行时间。进程描述符中的se字段便是该数据类型,se是当前进程的调度实体，该结构部分内容如下:

``` c
struct sched_entity {
        struct load_weight      load;           /* for load-balancing */
        struct rb_node          run_node;
        unsigned int            on_rq;
        u64                     exec_start;
        u64                     sum_exec_runtime;
        u64                     vruntime;
        u64                     prev_sum_exec_runtime;
};

```

vruntime变量存放进程的虚拟运行时间，**CFS使用vruntime来记录一个程序到底运行了多长时间以及它应该再运行多久**。可以简单地认为vruntime通过以下公式计算

``` c
vruntime ＝ delta_time / load
```

其中delta_time表示该进程以运行的时间，load表示进程对CPU的使用比，和nice值相关。当运行相同时间时，使用比大的进程vruntime更小，表明能获得更多的CPU时间。更新函数通过时钟中断调用。

**CFS调度算法的核心便是选择具有最小vruntime的进程，CFS使用红黑树来组织可运行进程队列**，并且通过红黑树迅速找到最小vruntime的进程。红黑树中的每一个节点的值便是vruntime,越小的vruntime，位置越靠左下，所以只需找到最左下的节点的进程。
