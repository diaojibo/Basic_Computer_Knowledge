## 协程

进程与线程都是操作系统可感知的，也就是说其调度完全是由操作系统来执行，不能通过人工参与。通常操作系统调度进程与线程主要有时间片轮询、优先级调度等方式。

当正在运行的线程时间片用光后，操作系统需要根据调度算法选择下一个线程到当前CPU运行。**线程与进程的切换是由操作系统完成的**，那么在线程与进程之间进行切换到底需要保存哪些状态，则需要研究进程与线程运行所需要的资源了。

 每一个进程运行在自己的虚拟地址空间，与其他进程互不干扰，进程维护着自己的

 1. 进程地址空间
 2. 堆栈
 3. 寄存器
 4. 堆

线程运行需要：

1. 堆栈
2. 寄存器；

进程上下文切换首先要切换地址空间然后保存寄存器状态，这个过程非常复杂，且相对耗时.

进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.

**zwlj:线程属于进程，进程通过调度霸占某个cpu，然后cpu会调度这个进程里的各个线程执行(多核的话就在不同核心中执行)。也就是说不会出现同一个进程内的线程在两个不同的cpu当中**

下面我们来看看协程是什么：

 - 协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等
 - 协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)**手动切换** 的,因此更加灵活,因此又叫用户空间线程.
 - 原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。

**一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。**

**zwlj：协程就相当于我们程序员手工执行了调度操作，可以理解为有点像C++的epoll,进行IO操作时不阻塞直接返回，从而在一个线程里做了多件事。总之就像是单线程实现多线程的活，多个协程不断轮切执行函数。**

切换协程的底层操作为：

 - 保存当前协程的上下文（运行栈，返回地址，寄存器状态）
 - 设置将要唤醒的协程的入口指令地址到IP寄存器
 - 恢复将要唤醒的协程的上下文

### 参考
[协程Coroutine原理](https://blog.csdn.net/tgxallen/article/details/79631334)

[进程、线程和协程的概念](https://juejin.im/post/5b0014b7518825426e023666)
