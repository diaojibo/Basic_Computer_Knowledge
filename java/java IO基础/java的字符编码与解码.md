## java的字符编码与解码

其实不只是java，所有语言处理字符串都是要遵循一定机制的。

首先还是要明确的，我们可以通过不同的编码方式(GBK UTF-8等)，将二进制数据，转换成字符串。同样的字符概念，在不同的编码方式下，二进制数据是不同的。

然后，我们也必须明确，不同地方用的编码方式是不同的。java程序编写运行时，如果不指明编码方式，则会用默认编码方式来进行处理，这个默认编码方式就是利用的操作系统里默认的编码方式。比如windows下很大几率是GBK编码。

同时，java内部处理字符串，用的是Unicode编码。更通俗一点说：**在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码(重)**。

下面来分析一个java字符串解析的例子：

``` java
String str = "中国";

byte[] b = str.getBytes();

b = str.getBytes("ISO-8859-1");
```

当定义一个字符串的时候，要告诉程序，这个字符串是什么编码类型的，这样在“保存文件”或者“网络传输”，的时候，才会知道**用什么样的方式去解析**。内存中，都是统一用的Unicode。

观察上面代码，当执行第一行赋值语句的时候，java程序首先会根据操作系统的默认编码GBK找到"中国"的二进制编码，但是字符串这个变量是在内存里的，所以java会查Unicode转换表，把GBK编码二进制数据转换成Unicode二进制数据放进内存里。

然后第二行，b获取了str的字节数组，但是这里是需要默认指定编码的，没有指定，那么就取default，也就是操作系统默认的编码GBK。所以java根据转换，把内存中的Unicode编码，转换成GBK编码，然后组成一个字节数组。

第三行是指定了一种方式。那么同理，就会用ISO的编码去编码内存中的unicode二进制数据，但这里会有问题。ISO编码集里没有中文对应的编码(也就是没有对应的二进制数据)，所以对应字符会返回一个0x3f字节，代表一个问号。所以bytes\[0\]=bytes\[1\] = 0x3f

### 乱码的原因
出现乱码，本质原因就是默认的解码环境不能满足字符的需求。

比如我有一个字符串str，里面都是中文，当然放到内存里都是Unicode，但是偏偏我大环境是ASCII，当我涉及操作(比如输出字符串到系统界面，或者需要处理bytes数组的时候)，默认会想将这个Unicode字符串转换成bytes数组，但是ASCII编码集显然不能处理中文，那这就乱码了。
