## 对象的创建、内存布局、访问定位
![](image/jvm0.jpg)
### 对象的创建
在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中探讨的对象限于普通对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？

#### 检查对象对应的类是否加载
虚拟机遇到一个new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程--也就是加载和连接。(参阅类加载机制)

#### 为新生对象分配内存
对象所需要的内存大小在类加载完成后便可以完全确定，此时需要从运行时数据区域中的堆中将特定大小的内存划分出来，给该对象。

内存划分（两种方式）：
 - **指针碰撞**，假设堆中内存绝对规整，用过的内存放一边，没用过的放一边，中间用一个指针作为分界点的指示器。**分配内存仅仅是将指针向空闲空间那边挪动一段与对象大小相等的距离**。
 - **空闲列表**，假设堆中内存不规整，已使用的和空闲的内存相互交错，此时，**虚拟机维护一个列表**，用来记录哪些内存可用。在分配内存时，从列表中找到一块足够大的空间划分给该对象实例，并更新列表上的记录。
到底使用哪种分配方式，与Java堆是否规整有关，而Java堆是否规整与所选用的垃圾收集器是否带有压缩整理功能决定。如果使用Serial、ParNew等带有Compact过程的收集器时，系统采用指针碰撞方式。如果使用CMS这种基于Mark-Sweep算法的收集器时，采用空闲列表方式。



除如何划分可用空间外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的操作，即使是**仅仅修改一个指针所指向的位置，在并发情况下是线程不安全的**，可能出现正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

划分时保证线程安全（两种方式）：
 - **对分配内存空间的动作进行同步处理**，虚拟机实际上采用CAS+失败重试的方式保证更新操作的原子性。
 - **把内存分配的动作按照线程划分在不同的空间上**。即每个线程在堆中预先分配一小块内存区域，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有当TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数设定。
