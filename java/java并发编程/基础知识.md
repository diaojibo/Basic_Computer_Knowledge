## 基础知识

### 线程安全性
当多个线程访问某个类，而这个类始终能表现出正确的行为，那么这个类是线程安全的。

### 竞态条件
竞态条件是指，并发编程中，由于不恰当的执行次序而出现的不正确结果，这样一种情况。比如两个线程对同一个变量的读取-修改-写入，执行次序不同，造成的结果也会不同。

### 原子操作
要么这个操作包含的动作全部发生，要不就全部不发生，作为一个整体，只有之前和之后两种状态，不可分割。

### 重入
重入意思就是，当一个线程试图获得一个已经由它自己持有的锁时，这个请求会成功，那这就是重入。
``` java
public class Widget {
  public synchronized void dth(){...}
}

public class LoggingWidget extends Widget{
  puiblic synchronized void dth(){
    super.dth();
    }
}

```

比如上面代码，如果java内置锁(synchronized锁)不可重入，则会陷入死锁。

### 可见性
线程对变量的修改都直接写入内存中。别的线程每一次都可以读取出最新修改的变量，这就是内存可见。

### 重排序
jvm为了提高性能，可能会对指令进行重排序，即打乱一些命令的执行顺序。先提一下两个概念。

#### 数据依赖性
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性

有三种情况。
<table>
<tr><td>名称</td><td>示例</td><td>说明</td></tr>
<tr><td>写后读</td><td>a = 1; b = a;</td><td>写一个变量后再读这个位置</td></tr>
<tr><td>写后写</td><td>a = 1; a = 2;</td><td>写一个变量后再写这个变量</td></tr>
<tr><td>读后写</td><td>a = b; b = 1;</td><td>读一个变量后再写这个变量</td></tr>
</table>

上面三种(带写)情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。

所以有数据依赖性的语句不能进行重排序。

#### as-if-serial
as-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。

编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。

**总之这个原则就是，不对有数据依赖性的命令进行重排序，以此来保护单线程的执行结果一定。**

*as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，写单线程的程序员有一个幻觉：单线程程序是按程序写的顺序来执行的。*

#### happens-before 规则
**语义：如果A先发生于B，那么A所做的所有改变都能被B看到**

遵循的规则

 - 程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
 - 监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。
 - volatile变量规则：对一个volatile域的写，happens- before 于任意后续对这个volatile域的读。
 - 传递性：如果A happens- before B，且B happens- before C，那么A happens- before C。

#### 重排序例子
``` java
class ReorderExample {
    int a = 0;
    boolean flag = false;

    public void writer() {
        a = 1;                   //1
        flag = true;             //2
    }

    Public void reader() {
        if (flag) {              //3
            int i =  a * a;      //4
            ……
        }
    }
}
```

flag为标志位，表示a有没有被写入，当A线程执行 writer 方法，B线程执行 reader 方法，线程B在执行4操作的时候，能否看到线程A对a的写入操作？

答案是: 不一定!

由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序(在这个线程内)。

如果操作1和操作2做了重排序，程序执行时，线程A首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！
