## volatile原理

在CPU实现原子操作的笔记中，我们对CPU如何保证原子性有了一定了解。那么Java环境下的原子性呢？

先回顾一下几个概念。

### 原子性
原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

``` java
i = 0;            ---1
j = i ;            ---2
i++;            ---3
i = j + 1;    ---4
```

上面四个操作，有哪个几个是原子操作，那几个不是？如果不是很理解，可能会认为都是原子性操作，其实只有1才是原子操作，其余均不是。

1—在Java中，对基本数据类型的变量和赋值操作都是原子性操作；
2—包含了两个操作：读取i，将i值赋值给j
3—包含了三个操作：读取i值、i + 1 、将+1结果赋值给i；
4—同三一样

在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的（注：**在32位的JDK环境下，对64位数据的读取不是原子性操作*，如long、double**）。要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。

所以volatile在多线程下其实不能保证原子性。
### 可见性
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

在上面已经分析了，在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。

**Java提供了volatile来保证可见性**。

当一个变量被volatile修饰后，表示着**线程本地内存无效**，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取(可见java内存模型笔记)。

当然，synchronize和锁都可以保证可见性。

### 有序性
有序性：即程序执行的顺序按照代码的先后顺序执行。

在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。重排序笔记可见*基础知识*。

Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。

### volatile
一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1. 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2. 禁止进行指令重排序。

那么实际机制呢？

首先我们已经了解了CPU维持原子性的原理，那么接下来看看java的内存工作模型。
![](image/volatile0.png)
工作内存Work Memory**其实就是对CPU寄存器和高速缓存的抽象**，或者说每个线程的工作内存也可以简单理解为CPU寄存器和高速缓存。

理解这一点非常关键，不能把这个内存工作模型的抽象和JVM内存区域划分搞混。

所以我们就可以直接从CPU指令层面理解volatile是如何工作的了，在x86处理器下通过工具获取JIT编译器生成的汇编指令来看看对Volatile进行写操作CPU会做什么事情。

<table cellspacing="0" cellpadding="0" border="1">
    <tbody>
        <tr>
            <td width="90" valign="top">
            <p>Java代码：</p>
            </td>
            <td width="463" valign="top">
            <p>instance = new Singleton();//instance是volatile变量</p>
            </td>
        </tr>
        <tr>
            <td width="90" valign="top">
            <p>汇编代码：</p>
            </td>
            <td width="463" valign="top">
            <p>0x01a3de1d: movb $0x0,0x1104800(%esi);</p>
            <p>0x01a3de24: <b>lock</b> addl $0x0,(%esp);</p>
            </td>
        </tr>
    </tbody>
</table>

有volatile变量修饰的共享变量进行写操作的时候会多第二行汇编代码,指令添加lock前缀。lock前缀的指令在多核处理器下会引发了两件事情。

 - 将当前处理器缓存行的数据(高速缓存里的数据)写回到系统内存。
 - 这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效(缓存锁)。



**zwlj：这里要着重讲一下volatile与原子性的关系。毫无疑问，volatile是根据缓存一致性来保证可见性，但却没能保证原子性。比如某个共享变量自增，线程1去读还没来得及修改就被线程2读了旧值。归根到底是因为，自增这个操作并非原子性的。volatile的内存屏障，通过缓存一致性只能保证对内存操作的原子性(详细一些内容见计组缓存一致性笔记)。volatile只能保证，可见性，如要保证自增的原子性可以用lock和Synchronize加锁或者用并发包里的原子类。**


上面叙述了volatile保证了可见性，而为了实现volatile内存语义，JMM还会限制重排序。

观察刚才加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障(其实不是内存屏障，但是提供了内存屏障的功能)。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过**内存屏障来实现的**。

所谓限制重排序，即是让程序在符合一定规则顺序的情况下执行。
![](image/volatile3.png)

 - 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
 - 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
 - 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。


关于内存屏障的机制，有机会将于另外的笔记中归纳:) ，现在仅做一个了解。

总之便是，volatile利用内存屏障(CPU的lock 写)，保证了可见性和有序性(遵循happens-before原则)。
