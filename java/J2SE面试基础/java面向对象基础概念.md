## java面向对象基础概念

### 面向对象的特征
Java面向对象的特征: 封装、继承、多态.三大特征
![](image/oop1.gif)

#### 封装
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

也就是说仅对外提供**公共访问方式**，是根据需要，把属性和方法捆绑在一起，就像一个保护器，**防止外界代码随意的访问**，而是根据该保护器定义的接口来控制。该机制保证了程序和数据都不受外部干扰且不被误用。封装代码的好处是每个人都知道怎么访问它，但却**不必考虑它的内部实现细节**，也不必担心使用不当会带来负面影响，在提高了安全性的基础上更加便于使用。

封装有以下优点

1. 实现了专业的分工
2. 良好的封装能够减少耦合
3. 类内部的结构能够自有修改
4. 可以对成员进行更精确的控制
5. 隐藏信息，实现细节

在Java中类中成员的属性有：public， protected， \<default\>， private，这四个属性的访问权限依次降低。

#### 继承
继承是指一个对象从另一个对象中获得属性和方法的过程。子类会继承父类的属性和行为，并且也可包含它们自己的，所以子类比父类要更加具体化。

它可以使子类在父类的基础上扩展

 - 实现继承是指使用基类的属性和方法而无需额外编码的能力；
 - 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

继承的优点：

1. 类具备的方法子类可以直接继承过来，不用重新书写，提高了代码的复用性
2. 让类与类之间产生关系(逻辑上的联系)，有了关系才有多态的实现


Java中只支持单继承，不支持多继承，因为多继承存在安全隐患（当多个父类存在同个功能时，子类不确定要运行哪一个），Java支持多层继承，即父类还可以继承其他类，java用另一种机制解决单继承的局限性，即多实现

##### 初始化顺序
记住继承链的初始化顺序。

初始化过程：
1. 初始化父类中的静态成员变量和静态代码块 ；
2. 初始化子类中的静态成员变量和静态代码块 ；
3. 初始化父类的普通成员变量和代码块，再执行父类的构造方法；
4. 初始化子类的普通成员变量和代码块，再执行子类的构造方法； 


#### 多态
**方法的重写**、**重载** 与 **动态连接**构成多态性。

多态性：发送消息给某个对象，让该对象自行决定响应何种行为。

通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。

java 的这种机制遵循一个原则：**当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法**，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。


#### 动态绑定

将一个方法调用和一个方法主体连接到一起称为绑定（Binding）。
根据绑定的时机不同，可将绑定分为“早期绑定”和“后期绑定”两种。
如果在程序运行之前进行绑定（由编译器和链接程序完成），称为早期绑定。
如果在程序运行期间进行绑定，称为后期绑定，后期绑定也称为“动态绑定”或“运行时绑定”。
在Java中，多态性是依靠动态绑定实现的，即Java虚拟机在运行时确定要调用哪一个同名方法。


多态三特性

1. 对象实例确定则不可改变（客观不可改变）
2. 只能调用编译时类型所定义的方法。
3. 运行时会根据运行时类型去调用相应类型中定义的方法。


#### override和overload
实现多态，有二种方式，覆盖（override），重载（overload）

方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。

**如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)**。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。**如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)**。


注意一下，Constructor(构造器)不能被继承，所以不能被override(重写)，但是可以被overloading(重载)。

方法的默认权限是protected，要注意子类重写父类方法的时候，**不能缩小访问权限**。比如父类是public，子类不能是protected或者是private。

#### 多态的好处
 - 提高了代码的维护性，减少耦合(继承保证)
 - 提高了代码的扩展性(由多态保证)

java中多态也有缺点，当父类引用指向子类对象时，虽然提高了扩展性，但是只能访问父类中具备的方法，不可以访问子类中特有的方法。(前期不能使用后期产生的功能，即访问的局限性)
