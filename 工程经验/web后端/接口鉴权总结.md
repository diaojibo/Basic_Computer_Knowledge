## 接口鉴权
总的来说，我们在后台进行接口鉴权的方式有以下几种：

1. HTTP Basic Authentication
2. session-cookie
3. Token 验证
4. OAuth(开放授权)


### HTTP Basic Authentication
这是一种利用HTTP协议自带的方式进行认证。

http请求的时候，服务器会先向客户端发送一个`WWW-Authenticate` 头部字段。比如整个头部如下：

```
HTTP/1.0 401 Unauthorised 
Server: SokEvo/1.0 
WWW-Authenticate: Basic realm=”google.com” 
Content-Type: text/html 
Content-Length: xxx

```

 当符合http1.0或1.1规范的客户端（如IE，FIREFOX）收到401返回值时，将自动弹出一个登录窗口，要求用户输入用户名和密码。用户输入用户名和密码后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中，则客户端发送的第一条请求信息则变成如下内容：

 ```
Get /index.html HTTP/1.0 
Host:www.google.com 
Authorization: Basic d2FuZzp3YW5n
 ```

 d2FuZzp3YW5n表示加密后的用户名及密码（用户名：密码 然后通过base64加密，加密过程是浏览器默认的行为，不需要我们人为加密，我们只需要输入用户名密码即可）.服务器收到上述请求信息后，将Authorization字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证，如用户名及密码正确，服务器则根据请求，将所请求资源发送给客户端

 这种验证方式的缺陷是加密方式简单，仅仅是base64加密，这种加密方式是可逆的。同时在每个请求的头上都会附带上用户名和密码信息，这样在外网是很容易被嗅探器探测到的。这种加密方式一般多被用在内部安全性要求不高的的系统上

### session-cookie
服务器在接受客户端首次访问时在，**经过登录后**，服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。 

浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求de 请求头中会带上该域名下的cookie信息。服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。

其实这种方式就比较经典了，就是客户端用cookie，服务端用session。

### Token 验证
使用Token验证的话，首先客户端使用用户名跟密码请求登录 ，然后服务端验证后签发一个Token回客户端。客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里。客户端每次向服务端请求资源的时候需要带着服务端签发的 Token。服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据

其实也很像cookie-session机制，不同的是Token是作为一种成功登录的凭证。而且不需要浏览器也可以实现认证。session机制占资源，且因为保存在内存中不适合分布式扩展。

Token鉴权机制非常灵活，可以专门做一个鉴权服务用它向多个服务的请求进行统一鉴权。

#### JWT(JSON WEB TOKEN)
说到token鉴权机制，那就不得不说一下JWT，json web token鉴权了。 JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成json对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。 

JWT其实就是一种特殊的Token，要生成这种Token,**我们必须把请求体的json部分分成三块： header，payload，Signature：**

header主要包含两部分：

 - Token的类型，这里是JWT
 - 声明加密的算法 通常直接使用 HMAC SHA256


```
{
  "alg": "HS256",
  "typ": "JWT"
}
```

payload部分，主要是一些真用户相关的信息：

```
{
  "id": "1234567890",
  "name": "mingshan",
  "admin": true
}
```

Signature部分，需要对上面的header和payload做一个加密，而加密当然需要一个secret密钥。以上面的header和payload为例，大概就是这样：

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```


用了header指定的加密算法，先把header整个部分做base64，然后以点号分割拼接payload的base64.最后使用secret密钥做一个加密。着整个Token的计算过程，都是在服务端算的哦！如此便可以得到一个JWT，这个token会被返回给客户端。

**注意，这个secret也是服务端生成保存的，不应该高速给外人知道。否则别人也可以自由签发token**。

总之JWT就是一种Token生成技术

### OAuth技术
待补充