# 性能测试工具总结
作为服务器开发人员，对性能应该非常的敏感，在服务器设计和编码时就应该充分考虑到性能问题，但如果写出来的程序，或者已经存在的程序在运行中出现了性能问题，我们又如何下手去找出问题并解决呢？这不仅靠的是经验，还需要借助一些工具来辅助分析。

**虽然介绍了很多，但最后建议直接上Perf，perf工具另开一个笔记详述**


### Grof
Linux下最常用的性能分析工具

Gprof是GNU profiler工具。可以显示程序运行的“flat profile”，包括每个函数的调用次数，每个函数消耗的处理器时间。也可以显示“调用图”，包括函数的调用关系，每个函数调用花费了多少时间。

 - 优点：Gprof一般系统自带，不用安装，历史悠久，稳定
 - 缺点：需要重新编译程序，对多线程无法支持（需要打patch),需要程序正常退出（很多服务器程序可能没有正常退出的方法）。

历史悠久的测试工具，所以这里不展开记录。

### Valgrind
Valgrind是一个GPL的软件，用于Linux（For x86, amd64 and ppc32）程序的内存调试、内存泄漏检测以及性能分析的软件开发工具。

 - 优点：无需编译程序，使用简单，直接运行就行，支持stl，支持系统库函数。

 - 缺点：valgrind程序本身会占用很多的cpu,导致测试程序本身的并发量上不去。


### oprofile
性能测试的神器。其结果最为准确

其原理是：现在的很多 CPU都提供一个所谓性能计数器的东西（performance counter），大致的原理就是程序可以注册告诉CPU对什么event感兴趣（比如CPU_CYCLE，CPU经历了一次时钟周期），然后CPU在执行了相应的操作后，就会在性能计数器上加1，这样程序就可以取出。所以，使用OProfile来定位CPU使用率的问题，就变成了让oprofile收集 程序运行过程中哪个可执行程序（或是so）中的哪个function，消耗的CPU CYCLE最多。

也就是说我们可以通过收集数据知道哪个程序的哪个函数消耗的cpu时间占比。这种测试方法结果更符合实际情况。

### perf
Perf 是用来进行软件性能分析的工具。通过它，应用程序可以利用 PMU，tracepoint 和内核中的特殊计数器来进行性能统计。它不但可以分析指定应用程序的性能问题 (per thread)，也可以用来分析内核的性能问题，当然也可以同时分析应用代码和内核，从而全面理解应用程序中的性能瓶颈。

简单来说，perf是一个很强大的软件性能分析工具，比oprofile更强大。

此工具已被许多Linux系统原生支持，通常，它的执行频率是 99Hz（每秒99次），如果99次都返回同一个函数名，那就说明 CPU 这一秒钟都在执行同一个函数，可能存在性能问题

#### 使用方法

使用方法

```
sudo perf record -F 99 -p 13204 -g -- sleep 30
```

上面的代码中，perf record表示记录，-F 99表示每秒99次，-p 13204是进程号，即对哪个进程进行分析，-g表示记录调用栈，sleep 30则是持续30秒.

运行后会产生一个庞大的文本文件。如果一台服务器有16个 CPU，每秒抽样99次，持续30秒，就得到 47,520 个调用栈，长达几十万甚至上百万行。

为了便于阅读，perf record命令可以统计每个调用栈出现的百分比，然后从高到低排列

#### 火焰图生成
火焰图(flame graph), 是基于 perf 结果产生的 SVG 图片，用来展示 CPU 的调用栈。

火焰图y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。x轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。**火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题**。


生成火焰图流程：

```
// 查看进程pid
ps aux|grep name

// 使用perf记录和生成
perf record -F 99 -p 101503 -m 4 -g -a -- sleep 60
perf script > out.perf
```

然后使用火焰图生成工具

```
git clone https://github.com/brendangregg/FlameGraph.git
cd FlameGraph

// 处理perf script
./stackcollapse-perf.pl out.perf > out.folded

// 绘制SVG
./flamegraph.pl out.folded > pmCount.svg
```

当调用栈过深时，某些系统只返回前面的一部分（比如前10层）。有些函数没有名字，编译器只用内存地址来表示（比如匿名函数）。