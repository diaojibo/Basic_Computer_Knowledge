## iTLB指令地址映射率优化

而生产实践中，我们经常发现一个问题：是**指令地址映射的不命中率太高（High iTLB miss rate）**，导致程序运行不够快。我们今天就探讨这个问题。 

 CPU 资源是最常见的性能瓶颈之一，因此提高CPU 性能，一直是许多性能工作的重点。 导致 CPU 性能不高的原因有很多，其中有一种原因就是**较高的 iTLB 不命中率**。这里的iTLB 就是 Instruction Translation Lookaside Buffer，也就是**指令转换后备缓冲区**。iTLB命中率不高，就会导致 CPU 无法高效运行。 

那么 TLB（转换后备缓冲区）又起到了什么作用呢？

在虚拟内存管理中，内核需要维护一个地址映射表，将虚拟内存地址映射到实际的物理地址，对于每个内存里的页面操作，内核都需要加载相关的地址映射。在 x86 计算 体系结构中，是用内存的页表（page table），来存储虚拟内存和物理内存之间的内存映射的。但是，内存页表的访问，相对于 CPU 的运算速度，那是远远不够快的。 

所以，为了能进行快速的虚拟到物理地址转换，TLB（转换后备缓冲区）这种专门的硬件就被发明出来了，它可以作为内存页表的缓存。TLB 有两种：**数据 TLB**（Data）和**指令TLB**（Instruction），也就是 iTLB 和 dTLB；因为处理器的大小限制，这两者的大小，也就是条目数，都不是很大，只能存储为数不多的地址条目。 

为什么说 TLB 的命中率很重要呢？内存页表的访问延迟比 TLB 高得多；因此命中 TLB 的地址转换，比未命中 TLB 也就快得多。因为 CPU 无时无刻不在执行指令，所以 iTLB 的性能尤其关键。iTLB 未命中率，是衡量因 iTLB 未命中而导致的性能损失的度量标准。**当 iTLB 未命中率很高时，CPU将花费大量周期来处理未命中，这就导致指令执行速度变慢。**

具体来讲，iTLB 命中和不命中之间的访问延迟，差异可能是 10 到 100 倍。命中的话，仅需要 1 个时钟周期，而不命中，就需要 10-100 个时钟周期，因此 iTLB 不命中的代价是极高的。 

我们可以用具体的数据来感受一下。假设这两种情况分别需要 1 和 60 个时钟周期，未命中率为 1％，将导致平均访问延迟为 1.59 个周期，相比全部命中的情况（即 1 个周期）的访问延迟，足足高出 59％。 

### 提高手段

对于 iTLB 命中率不高的系统，如果能提高命中率，可以大大提高 CPU 性能并加快服务运行时间。我们在生产过程中实践过两种方案，下面分别介绍。

第一种方案，是优化软件的二进制文件来减少 iTLB 不命中率。

一般而言，根据编译源代码的不同阶段（即编译、链接、链接后等阶段），分别存在三种优化方法。这样的例子包括优化编译器选项，来对函数进行重新排序，以便将经常调用的所 谓“热函数”放置在一起，或者使用 FDO（Feedback-Directed Optimization，就是基于反馈的优化）来减少代码区域的大小

FDO 是什么呢？简单来说，就是把一个程序放在生产环境中运行，剖析真实的生产数据， 并且用这些信息来对这个程序进行精准地优化。比如，可以确切地知道在生产环境中，每个函数的调用频率。 

我们可以通过编译优化来将频繁被访问的指令汇总到一起，放在二进制文件中的同一个地方，以提高空间局部性，这样就可以提高 iTLB 命中。这块放置频繁访问指令的区域，就叫**热区域**（Hot Text）。 

####  二进制优化过程

我们可以通过Linux的Perf工具来分析二进制文件的热指令

有两种方法来进行识别：

- 可以使用堆栈跟踪
- 也可以使用**LBR**（Last Branch Record，最后分支记录）。

LBR 比较适宜，是因为它的好处是能提高数据质量，并减少数据占用量。 

其次，根据函数的访问频率，对配置文件函数进行排序。我们可以使用名为**HFSort**的工具，来为热函数创建优化表单。 

最后，链接器脚本将根据访问顺序，优化二进制文件中的函数布局。这些步骤执行完毕后的结果就是一个优化的二进制文件。

#### 采用大页面

现代计算机系统，除了传统的 4KB 页面大小之外，通常还支持更大的页面大小，比如 x86_64 上分别为 2MB 和 1GB。这两种页面都称为大页面。使用较大的页面好处是，减少了覆盖二进制文件的工作集所需的 TLB 条目数，从而用较少的页面表就可以覆盖所有用到的地址，也就相应地降低了采用页面表地址转换的成本。 

在 Linux 上，有两种获取大页面的方法：

- 手工：预先为应用程序预留大页面；
- 自动：使用透明大页面，也就是THP（Transparent Huge Pages）。

THP，就像名字一样，是由操作系统来自动管理大页面，不需要用户去预留大页面。THP的显著优点是**不需要对应用程序做任何更改**；但是也有缺点，就是**不能保证大页面的可用性**。预留大页面的方式，则需要在启动内核时应用配置。假如我们想保留 64 个大页面，每个 2MB，就用下面的配置。 

`hugepagesz = 2MB， hugepages = 64`

我们在服务器上运行程序时，需要将相应的二进制文件加载到内存中。二进制文件由一组函数指令组成，它们共同位于二进制文件的文本段中，每个页面都尝试占用一个 iTLB 条目来进行虚拟到物理页面的转换。 

如果内存页（比如 4KB）很小，那么对于一定大小的程序，需要加载的内存页就会较多，内核会加载更多的映射表条目，而这会降低性能。通常在执行过程中，我们使用 4KB 的普通页面。如果使用“大内存页”，页面变大了（比如 2MB 是 4KB 的 512 倍），自然所需要的页数就变少了，也就大大减少了由内核加载的映射表的数量。这样就提高了内核级别的性能，最终提升了应用程序的性能。这就是大页面为什么会被引入的原因。 

好比Intel HasWell架构中 4KB 页面有 128 个条目，每个条目覆盖 4KB，总共只能覆盖 512KB 大小的文本段。如果应用程序大于 512KB，就会有 iTLB 不命中，从而需要去访 问内存的地址映射表，这就比较慢了。iTLB 未命中的处理是计入 CPU 使用时间的，所以等待访问内存地址映射的过程，就实际上浪费了 CPU 时间。 

当代的 CPU 体系结构，通常为大页面提供一些单独的 TLB 条目，如果我们不 使用大页面，这些条目将处于空闲状态。所以，通过使用大页面，也可以充分利用那些TLB 条目。 