## 以太坊概念基础
现行法律的本质是一种合约。它是由（生活于某一社群的）人和他们的领导者之间所缔结的，一种关于彼此该如何行动的共识。个体之间也存在着一些合约，这些合约可以理解为一种私法，相应的，这种私法仅对合约的参与者生效。

我们已经知道了法律就是一种合约，然而，一直以来，现行的法律体系都存在着两个巨大的问题：
 1. 合约或法律是由充满歧义的语句定义的
 2. 强制执行合约或法律的代价非常大。

以太坊，**通过数字货币和编程语言的结合**，解决了现行法律体系的这两大问题。

以太坊采用区块链的原理，又增加了在区块链上创建智能合约：智能合约是一种应用，它能保存价值，存储数据，封装代码，执行计算任务。类似比特币，以太坊也含有货币，称为以太(ether)。以太是计算机节点挖出来的，由节点验证交易，交易存储在分布共识的区块链中。以太可以在账户(公钥)之间以及智能合约之间转移。

在对比特币的机制有一定了解的基础上，我们来看看以太坊的设计原则。

### 区块链层协议
本节对以太坊中区块链层协议的改变进行了描述，包括区块和交易是如何工作的、数据如何序列化及存储、账户背后的机制。

#### 使用账户而非UTXO
比特币及其许多衍生品，都将用户的余额信息存储在UTXO结构中，系统的整个状态由一系列的“有效的输出”组成（可以将这些“有效的输出”想象成钱币）。每个UTXO都有拥有者和自身的价值属性。一笔交易在消费若干个UTXO同时也会生成若干个新的UTXO。

“有效的输出”中有效需满足下面几点约束：

1. 每个被引用的输入必须有效，且未被使用过；
2. 交易的签名必须与每笔输入的所有者签名匹配；
3. 输入的总值必须等于或大于输出的总值。

但是，**以太坊抛弃了UTXO的方案**，转而使用更简单的方法：**采用状态(state)的概念存储一系列账户**，每个账户都有自己的余额，以及以太坊特有的数据（代码或内部存储器）。如果交易发起方的账户余额足够支付交易费用，则交易有效，那么发起方账户会扣除相应金额，而接受账户则计入该金额。

某些情况下，接受账户内有需要执行的代码，则交易会触发该代码的执行，那么账户的内部存储器可能就会发生变化，甚至可能会创建额外的信息发送给其他账户，从而导致新的交易发生。

##### UTXO vs 账户

UTXO有以下优点：

1. **较高程度的隐私保护**，如果用户每次交易都使用一个新的地址，那么账户之间的相互关联就很困难。这样做适用于对安全性要求高的货币系统，但对任何dapp应用来说就不合适了。因为dapp通常需要跟踪用户复杂的绑定状态，而dapp的状态并不能像货币系统中的状态那样简单地划分。

2. **潜在地可扩展性**，UTXO在理论上可扩展性更好。因为我们只能依靠那些金融货币拥有者来维护能够证明货币所有权的默克尔树，即使所有的人(包括数据的拥有者)都遗忘了某一数据，真正受损也只有数据的拥有者，其他人不受影响。

账户的优点：

1. **节省大量空间**，不需要存储太多的UTXO，只需要存储一个账户地址。

2. **可替代性更高**，在UTXO结构中，“有效输出”的源码实现中没有区块链层的概念，所以不管是在技术还是法律上，通过建立一个红名单/黑名单，并依据的这些“有效输出”的来源区分它们并不是很实际。

3. **简单**，以太坊编码更简单、更易于理解

4. **轻客户端**，轻客户端可以随时通过沿指定方向扫描状态树来访问与账户相关的所有数据。在UTXO方式中，引用随着每个交易的变化而变化，这对于长时间运行并使用了上文提到的UTXO根状态传播机制的dapp应用来说，无疑是繁重的。


#### 以太坊账户
以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，**以太坊有两种类型的账户：外部所有的账户**（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。

就是简单理解为，就是两种账户：

![](image/eth0.png)

一种外部账户，就是普通账户。一种是合约账户，合约账户允许外部账户向其发消息，从外部拥有账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作。（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。

**合约账户不可以自己发起一个交易。相反，合约账户只有在接收到一个交易之后(从一个外部拥有账户或另一个合约账户接)，为了响应此交易而触发一个交易。**

![](image/eth1.png)

以太坊的账户包含四个部分，**不论账户类型是什么，都存在这四个组成部分**：

 - 随机数nonce：如果账户是一个外部拥有账户，nonce代表从此账户地址发送的交易序号。如果账户是一个合约账户，nonce代表此账户创建的合约序号

 - 余额balance： 此地址拥有Wei的数量。1Ether=10^18Wei

 - storageRoot： Merkle Patricia树的根节点Hash值。Merkle树会将此账户存储内容的Hash值进行编码，默认是空值

 - codeHash：此账户EVM（以太坊虚拟机）代码的hash值。对于合约账户，就是被Hash的代码并作为codeHash保存。对于外部拥有账户，codeHash域是一个空字符串的Hash值

 ![](image/eth2.png)

#### 消息和交易
以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同

1. 以太坊的消息可以由 **外部实体或者合约** 创建，然而比特币的交易只能从外部创建。
2. 以太坊消息可以选择包含数据
3. 如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。

### 状态与Merkle树
以太坊全局需要维护账户以及对应的账户状态。这跟比特币不同，比特币需要维护的，是全局每个交易，及对应的交易状态。而以太坊的链，直接要保存账户状态信息。

我们在密码学基础笔记里已经提到过Merkle树

![](image/eth3.png)

一系列的中间的节点，这些节点是两个子节点的Hash值。而 **叶子节点里存储的，就是账户状态**。bitcoin里，Merkle树维护的是交易状态，而这里是直接维护账号状态。叶子节点对应的都是每个账户，包括每个账户的balance, nonce, codeHash和storageRoot（storageRoot自己就是一颗树）。

![](image/eth4.png)

同样的树结构也用来存储交易和收据。更具体的说，**每个区块Block都有一个头(header)，保存了三个不同Merkle trie结构的根节点的Hash**，包括：

1. 状态树
2. 交易树
3. 收据树

![](image/eth5.png)

可见Block Header里，下面有三棵树的根节点hash。

#### 全节点与轻节点

在Merkle tries中存储所有信息的高效性在以太坊中的“轻客户端”和“轻节点”相当的有用。

广泛的说，有两种节点类型：全节点和轻节点。

**全节点通过下载整条链来进行同步**，从创世纪块到当前块，执行其中包含的所有交易。通常，矿工会存储全节点，因为他们在挖矿过程中需要全节点。也有可能下载一个全节点而不用执行所有的交易。无论如何，一个全节点包含了整个链。

比起下载和存储整个链以及执行其中所有的交易，**轻节点仅仅下载链的头**，从创世纪块到当前块的头，不执行任何的交易或检索任何相关联的状态。由于轻节点可以访问块的头，而头中包含了3个tries的Hash，所有轻节点依然可以很容易生成和接收关于交易、事件、余额等可验证的答案。

这个可以行的通是因为在Merkle树中hash值是向上传播的—如果一个恶意用户试图用一个假交易来交换Merkle树底的交易，这个会改变它上面节点的hash值，而它上面节点的值的改变也会导致上上一个节点Hash值的改变，以此类推，一直到树的根节点。

zwlj：如果拜占庭节点恶意修改区块数据，必然会产生一个hash不一样的区块头，这时正常节点接收到这个异常链，就会从异常节点处开启一个分叉。


![](image/eth6.png)

### Gas和费用
在以太坊中一个比较重要的概念就是费用(fees)，由以太坊网络上的交易而产生的每一次计算，都会产生费用—没有免费的午餐。这个费用是以称之为”gas”的来支付。

gas就是用来衡量在一个具体计算中要求的费用单位。gas price就是你愿意在每个gas上花费Ether的数量，以“gwei”进行衡量。“Wei”是Ether的最小单位，1Ether表示10^18Wei. 1gwei是1,000,000,000 Wei。

对每个交易，**发送者设置gas limit和gas price**。gas limit和gas price就代表着发送者愿意为执行交易支付的Wei的最大值。

例如，假设发送者设置gas limit为50,000，gas price为20gwei。这就表示发送者愿意最多支付50,000*20gwei = 1,000,000,000,000,000 Wei = 0.001 Ether来执行此交易。

![](image/eth7.png)

记住gas limit代表用户愿意花费在gas上的钱的最大值。如果在他们的账户余额中有足够的Ether来支付这个最大值费用，那么就没问题。在交易结束时任何未使用的gas都会被返回给发送者，以原始费率兑换。

![](image/eth8.png)

在发送者没有提供足够的gas来执行交易，那么交易执行就会出现“gas不足”然后被认为是无效的。在这种情况下，交易处理就会被终止以及所有已改变的状态将会被恢复，最后我们就又回到了交易之前的状态—完完全全的之前状态就像这笔交易从来没有发生。因为机器在耗尽gas之前还是为计算做出了努力， 所以理论上，将不会有任何的gas被返回给发送者。

![](image/eth9.png)

这些gas的钱到底去了哪里？发送者在gas上花费的所有钱都发送给了“受益人”地址，通常情况下就是矿工的地址。因为矿工为了计算和验证交易做出了努力，所以矿工接收gas的费用作为奖励。

![](image/eth10.png)

通常，发送者愿意支付更高的gas price，矿工从这笔交易总就能获得更多的价值。因此，矿工也就更加愿意选择这笔交易。这样的话，矿工可以自由的选择一笔交易自己愿意验证或忽略。为了引导发送者应该设置gas price为多少，矿工可以选择建议一个最小的gas值他们愿意执行一个交易。

#### 存储费用
gas不仅仅是用来支付计算这一步的费用，而且也用来支付存储的费用。存储的总费用与所使用的32位字节的最小倍数成比例。

存储费用有一些比较细微的方面。比如，由于增加了的存储增加了所有节点上的以太坊状态数据库的大小，所以激励保持数据存储量小。为了这个原因，如果一个交易的执行有一步是清除一个存储实体，那么为执行这个操作的费用就会被放弃，并且由于释放存储空间的退款就会被返回给发送者。

#### 费用的意义
计算的操作在以太坊虚拟机上是非常昂贵的。因此，以太坊智能合约最好是用来执行最简单的任务，比如运行一个简单的业务逻辑或者验证签名和其他密码对象，而不是用于复杂的操作，比如文件存储，电子邮件，或机器学习，这些会给网络造成压力。施加费用防止用户使网络超负荷。

以太坊是一个图灵完备语言（短而言之，图灵机器就是一个可以模拟任何电脑算法的机器。对于图灵机器不太熟悉的人可以看看这个 和这个 ）。这就允许有循环，并使以太坊受到停机问题 的影响，这个问题让你无法确定程序是否无限制的运行。如果没有费用的话，恶意的执行者通过执行一个包含无限循环的交易就可以很容易的让网络瘫痪而不会产生任何反响。因此，费用保护网络不受蓄意攻击。

你也许会想，“为什么我们还需要为存储付费？”其实就像计算一样，以太坊网络上的存储是整个网络都必须要负担的成本。

### 交易和消息
以太坊是一个基于交易的状态机。换句话说，在两个不同账户之间发生的交易会让以太坊全局状态从一个状态转换成另一个状态。

最基本的概念，一个交易就是被外部账户生成的加密签名的一段指令，序列化，然后提交给区块链。

有两种类型的交易：消息通信和合约创建(也就是交易产生一个新的以太坊合约)。

不管什么类型的交易，都包含：

1. nonce：发送者发送交易数的计数
2. gasPrice：发送者愿意支付执行交易所需的每个gas的Wei数量
3. gasLimit：发送者愿意为执行交易支付gas数量的最大值。这个数量被设置之后在任何计算完成之前就会被提前扣掉
4. to：接收者的地址。在合约创建交易中，合约账户的地址还没有存在，所以值先空着
5. value：从发送者转移到接收者的Wei数量。在合约创建交易中，value作为新建合约账户的开始余额
6. v,r,s：用于产生标识交易发生着的签名
7. init（只有在合约创建交易中存在）：用来初始化新合约账户的EVM代码片段。init值会执行一次，然后就会被丢弃。当init第一次执行的时候，它返回一个账户代码体，也就是永久与合约账户关联的一段代码。
8. data（可选域，只有在消息通信中存在）：消息通话中的输入数据(也就是参数)。例如，如果智能合约就是一个域名注册服务，那么调用合约可能就会期待输入域例如域名和IP地址

![](image/eth11.png)

我们之前其实有提到交易—消息通信和合约创建交易两者都总是被外部拥有账户触发并提交到区块链的。换种思维思考就是，交易是外部世界和以太坊内部状态的桥梁。

当一个合约发送一个内部交易给另一个合约，接受合约账户的相关联的代码就会被执行。

![](image/eth12.png)


一个重要需要注意的事情是内部交易或者消息不包含gasLimit。因为gas limit是由原始交易的外部创建者决定的（也就是外部拥有账户）。外部拥有账户设置的gas limit必须要高到足够将交易完成，包括由于此交易而长生的任何”子执行”，例如合约到合约的消息。如果，在一个交易或者信息链中，其中一个消息执行使gas已不足，那么这个消息的执行会被还原，包括任何被此执行触发的子消息。不过，父执行没必要被还原。

### 区块
在以太坊中，一个区块包含：

1. 区块头
2. 关于包含在此区块中交易集的信息
3. 与当前块的ommers相关的一系列其他区块头

#### Ommers
“ommer”到底是什么？

由于以太坊的构造，它的区块生产时间（大概15秒左右）比其他的区块链例如Bitcoin（大概10分钟左右）要快很多。这使得交易的处理更快。但是，更短的区块生产时间的一个缺点就是：更多的竞争区块会被矿工发现。这些竞争区块同样也被称为“孤区块”（也就是被挖出来但是不会被添加到主链上的区块）。

一个ommer是一个块，其父区块等于当前块的父区块的父区块。**用树来说的话，就是当前节点父节点的兄弟节点，就是一个当前区块的ommer**

 Ommers的目的就是为了帮助奖励矿工纳入这些孤区块。矿工包含的ommers必须是有效的，也就是ommers必须在父区块的第6个子区块之内(深度6)或更小范围内。在第6个子区块之后，陈旧的孤区块将不会再被引用（因为包含老旧的交易会使事情变得复杂一点）。

Ommer区块会收到比全区块少一点的奖励。不管怎样，依然存在激励来让矿工们纳入孤区块并能从中获得一些报酬。

### 区块头
讲到区块头，又要涉及到刚才发过那张老图了。

![](image/eth5.png)

header包括什么字段，上面也都描述清楚了。

 - parentHash：父区块头的Hash值（这也是使得区块变成区块链的原因）
 - ommerHash：当前区块ommers列表的Hash值
 - beneficiary：接收挖此区块费用的账户地址
 - stateRoot：状态树根节点的Hash值（回忆一下我们之前所说的保存在头中的状态树以及它使得轻客户端认证任何关于状态的事情都变得非常简单）
 - transactionsRoot：包含此区块所有交易的Merkle树的根节点Hash值
 - receiptsRoot：包含此区块所有交易收据的Merkle树的根节点Hash值
 - logsBloom：由日志信息组成的一个Bloom过滤器 (一种数据结构)
 - difficulty： 此区块的难度级别
 - number：当前区块的计数（创世纪块的区块序号为0，对于每个后续区块，区块序号都增加1）
 - gasLimit：每个区块的当前gas limit
 - gasUsed： 此区块中交易所用的总gas量
 - timestamp：此区块成立时的unix的时间戳
 - extraData：与此区块相关的附加数据
 - mixHash：一个Hash值，当与nonce组合时，证明此区块已经执行了足够的计算
 - nonce：一个Hash值，当与mixHash组合时，证明此区块已经执行了足够的计算

注意区块头里有前面提到的三个Merkle树树根

#### 日志
以太坊允许日志可以跟踪各种交易和消息。合约可以通过定义想要记录的“事件”来明确地生成日志。

日志条目包含：

1. 记录器的帐户地址，
2. 一系列代表这次交易所进行的各种事件的话题
3. 任何与这些事件相关的数据。

日志存储在boom过滤器中，以高效的方式存储无尽的日志数据。

#### 收据
自于被包含在交易收据中的日志信息存储在头中。正如您在商店买东西时收到收据一样，以太坊会为每笔交易生成收据。就像你所期望的那样，每个收据都包含有关交易的某些信息。



### 参考
[干货 | 以太坊设计原理](https://ethfans.org/posts/510)

[以太坊学习](https://www.jianshu.com/p/220130b39e22)

[以太坊白皮书](https://ethfans.org/wikis/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6)

[详解以太坊的工作原理](https://www.8btc.com/article/142319)
