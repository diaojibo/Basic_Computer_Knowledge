## 视图
在 MySQL 里，有两个“视图”的概念：

 - 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
 - 另一个是 InnoDB 在实现 MVCC(MVCC (Multiversion Concurrency Control)，即多版本并发控制技术) 时用到的**一致性读视图**，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。


它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。

### View in MVCC
在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。

这时，你会说这看上去不太现实啊。如果一个库有 100G，那么我启动一个事务，MySQL 就要拷贝 100G 的数据出来，这个过程得多慢啊。可是，我平时的事务执行起来很快啊。

实际上，我们并不需要拷贝出这 100G 的数据。我们先来看看这个快照是怎么实现的。

**InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id**。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 **row trx_id**。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。

也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

如图 2 所示，就是一个记录被多个事务连续更新后的状态，**注意下图指的都是同一个记录，id是同一个，但是执行事务的row tx id则不是同一个**。

![](image/mysql004.png)

图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是被 transaction id 为 25 的事务更新的，因此它的 row trx_id 也是 25。

还要注意，上图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。

明白了多版本和 row trx_id 的概念后，我们就可以知道，InnoDB 是怎么定义那个“100G”的快照的。按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。

因此，一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。

**在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交**。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。**而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。**

这个视图数组把所有的 row trx_id 分成了几种不同的情况。

![](image/mysql005.png)

所以，在事务启动的时候，一个数据版本的 row trx_id(也就是某行数据当前的trx_id)，有以下几种可能：

 - 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；

 - 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；

 - 如果落在黄色部分，那就包括两种情况
   - a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
   - b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。


zwlj：这里还是要再明确一下，我们每个事务启动的时候都会拿到一个事务id的数组，这个数组有最小到最大就敲定了一个事务范围。比活跃事务id最小位还小的(但没出现在活跃数组)，说明这个事务已经完成被commit了，如果有个事务id落在黄色区域，也就是最小值和最大值中间。那么如果它在数组里，说明还在执行，没在数组里则说明已经commit了。因为有id比较大的事务也是有可能比id小的事务先执行完的。

比如，对于上上张图中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。

![](image/mysql004.png)

有了这个声明后，系统里面随后发生的更新，是不是就跟这个事务看到的内容无关了呢？因为之后的更新，生成的版本一定属于上面的 2 或者 3(a) 的情况，而对它来说，这些新的数据版本是不存在的，所以这个事务的快照，就是“静态”的了。**InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**

#### 实例分析

![](image/mysql006.png)

有上面的事务执行情况，start transaction with consistent snapshot 这个命令说明马上启动一个事务。

假如id=1的位置，k的初始值是1.则最后结果是事务A select出来的是k=1，B计算出的k为3，C则是执行完k=2

我们来捋一捋顺序：

这里，我们不妨做如下假设：

1. 事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；
2. 事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；
3. 三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。


这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。

![](image/mysql007.png)

从图中可以看到，第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。

第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。**zwlj：这里也要注意，一个事务在update数据的时候，确实是会以最新的为准的，和视图啥的就无关，读数据的时候才会有不可重复读这种特性**

在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：

 - 找到 (1,3) 的时候，判断出 row trx_id=101，比高水位大，处于红色区域，不可见；
 - 接着，找到上一个历史版本，一看 row trx_id=102，比高水位大，处于红色区域，不可见；
 - 再往前找，终于找到了（1,1)，它的 row trx_id=90，比低水位小，处于绿色区域，可见。

一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：

1. 版本未提交，不可见；
2. 版本已提交，但是是在视图创建后提交的，不可见；
3. 版本已提交，而且是在视图创建前提交的，可见。


综合这个例子，对于update语句也有规则要记住：**更新数据(update)都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。** 也就是说update无论如何都会基于拿到的trx id，然后在这个基础上update

对select语句加锁，也会变成这种**当前读**的模式，也就是说拿到最新值。加上 lock in share mode 或 for update，也都可以读到版本号是 101 的数据，返回的 k 的值是 3。下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）。

```
mysql> select k from t where id=1 lock in share mode;
mysql> select k from t where id=1 for update;
```

更进一步，假如我们刚才的事务C改写成这样：

![](image/mysql008.png)

结合我们行锁的知识，C执行update以后，B执行，但是由于update会拿到行级锁，只有等到C commit以后B再执行。结果就跟以前一样了。

#### 可重复读&读提交的视图创建
所以什么是可重复读的事务特性呢？结合上面的例子就很好理解了

 - 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；
 - 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。(zwlj：这就很好理解了吧，读提交，一旦别的事务提交(并且释放了锁)，之后本事务也能看到，而不是只看静态视图的)

因为可重复读需要不停的去检索活跃事务id，所以并发程度低，但是安全程度就高了，所以属于事务四个级别里的第三个，仅次于串行。

结合上面的知识，读提交状况下的view使用情况如图，**这个案例也很重要，要细看**：

![](image/mysql009.png)

在读提交的情况下，**每一个语句执行前都会创建一个视图**。所以不难分析出，上图，A只能得到2，而B get得到3。

首先C先改到2提交，B在get的时候创建出一个视图，一个视图对应一组事务id数组，也就是100，101，此时升级到3，自然能get到自己3.

而对于A，此时get，会创建一个视图，得到事务id100，101，此时数据为101，落在了黄色区域。这说明该数据还没commit但事务仍旧活跃，根据读提交的特性，这个数据版本不读，用redo log往前回退来读。所以是2。