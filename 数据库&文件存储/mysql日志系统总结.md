# mysql日志系统

在mysql精讲笔记里，其实已经提到了binlog redolog的一些作用。这里直接归纳一下mysql用到的一些日志：



MySQL中有七种日志文件，分别是

1. 重做日志（redo log）
2. 回滚日志（undo log）
3. 二进制日志（binlog）
4. 错误日志（errorlog）
5. 慢查询日志（slow query log）
6. 常规日志（general log）
7. 中继日志（relay log）



### 重做日志（redo log）

在mysql精讲的一些笔记里我们知道，为了提高效率，数据库写数据操作会把操作都先写到一个粉板上，然后再找时间统一进行写入。这个redo log就是在这个场景下，帮助我们记录这些粉板操作的，它提供了crash safe的能力。

重做日志（redo log）的作用是确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘。
在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的持久性这一特性。



mysql通过redo log 把磁盘的随机IO 变为 日志的顺序IO， 提升写的效率。当对应事务的脏页写入到磁盘之后，redo log 的使命也就完成了，重做日志占用的空间就可以重用（被覆盖），redo log是环形写入的。



### 回滚日志（undo log）

保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。



事务开始之前，将当前时的版本生成 undo log，undo 也会产生 redo 来保证 undo log 的可靠性。



#### zwlj

例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为`<T1, X, 5>`，Redo日志为`<T1, X, 15>`。



redo日志应首先持久化在磁盘上，然后事务的操作结果才写入db buffer，（此时，内存中的数据和data file对应的数据不同，我们认为内存中的数据是脏数据），db buffer再选择合适的时机将数据持久化到data file中。这种顺序可以保证在需要故障恢复时恢复最后的修改操作。先持久化日志的策略叫做`Write Ahead Log`，即预写日志。



### 二进制日志（binlog）

用于复制，在主从复制中，从库利用主库上的 binlog 进行重播，实现主从同步；用于数据库基于时间点的还原。

逻辑格式的日志，可以简单认为就是执行过的事务中的 SQL 语句，但又不完全是 SQL 语句这么简单。
它包括了执行的 SQL 语句（增删改）反向的信息，也就意味着 delete 对应着 delete 本身和其反向的 insert；update 对应着 update 执行前后的版本的信息；insert 对应着 delete 和 insert 本身的信息。
在使用 MySQLbinlog 解析 binlog 之后一些都会真相大白。因此可以基于 binlog 做到类似于 Oracle 的闪回功能，其实都是依赖于 binlog 中的日志记录。

### 错误日志（errorlog）

错误日志是一个文本文件。
错误日志主要记录
    服务器启动和关闭过程中的信息
    服务器运行过程中的错误信息
    事件调度器运行一个时间是产生的信息
    在从服务器上启动从服务器进程是产生的信息

指定 log_error， 可以指定错误日志的文件

错误日志是一个标准的日志文本文件， 记录错误的详细信息

### 慢查询日志（slow query log）

当语句执行时间较长时，通过日志的方式进行记录，这种方式就是慢查询的日志。

缺省情况下慢查询日志记录在 hostname-slow.log为慢查询日志文件名，存放到数据目录，同时缺省情况下未开启慢查询日志。
缺省情况下数据库相关管理型SQL(比如OPTIMIZE TABLE、ANALYZE TABLE和ALTER TABLE)不会被记录到日志。

### 常规日志、通用查询、全量日志（general log）

开启后，记录client和数据库的所有请求



### 中继日志（relay log）

中继日志来自Master的二进制日志，IO线程从Master读取，然后写入本地的一类日志，类似于binary log。作为SQL线程的输入，中继日志中的事件将通过SQL线程来重演，从而实现复制。