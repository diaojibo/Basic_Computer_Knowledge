## 事务
事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个**程序执行单元unit**。在计算机术语中，事务通常就是指数据库事务。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

P.S:MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。

### 事务的ACID特性
对于事务来说，最重要的就是其满足ACID的特性。

并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：**原子性、一致性、隔离性、持久性**。这四个属性通常称为ACID特性。

 - **原子性（Atomicity）**：事务作为一个整体被执行，包含在其中的对数据库的操作**要么全部被执行，要么都不执行**，出现失败要执行**回滚**操作。

 - **一致性（Consistency）**：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应**满足完整性约束**。比如a转账给b，不能a扣钱，b没加钱，两边必须保持一致性

 - **隔离性（Isolation）**：多个事务并发执行时，一个事务的执行**不应影响其他事务的执行**。

 - **持久性（Durability）**：一个事务一旦提交，他对数据库的修改应该**永久保存在数据库中**。


总结一下便是，**原子性是基础，隔离性是手段，持久性是目的，真正最重要的是一致性**。


### 事务的隔离级别
在数据库操作中，为了有效保证**并发读取数据**的正确性，提出的事务隔离级别。

说白了就4个级别

 - READ_UNCOMMITTEED (读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到)
 - READ_COMMITTEED (读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。)
 - REPEATABLE_READ (可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。)
 - SERIALIZABLE (当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。)

从上往下，级别越来越高，并发性越来越差，安全性越来越高。

隔离性可谓是ACID特性中最难理解的了，高并发问题下不能出一点差池。

那么就不得不说一下高并发下，产生的问题。

#### 脏读Dirty Read
脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

当一个事务正在多次修改某个数据，而在这个事务中这**多次的修改都还未提交**，这时一个并发的事务来访问该数据，就会造成两个事务**得到的数据不一致**。例如：用户A向用户B转账100元

![](image/transaction0.jpg)

如上图，一个事务执行到一半，另一个事务去读取数据，最后事务A却回滚了，这样事务B就读到了无效数据，脏读。

#### 不可重复读(Unrepeatable Read)
不可重复读是指在一个事务范围中2次或者多次查询同一数据M返回了不同的数据

![](image/transaction1.jpg)

如上图所示，事务A完成了事务之后，事务B反复读取(可能是为了校验)，结果最后读出来的数据不同了。

这种现象基本上是可以理解的，但在某些“变态”场景下不允许。

#### 虚读(幻读)Phantom Read
当用户读取某一个范围的数据行时，另一个事务又在该范围内查询了新行，当用户再读取该范围的数据行时，会发现会有新的“幻影行”

第二次查询的结果包含了第一次查询中未出现的数据或者缺少了第一次查询中出现的数据（**这里并不要求两次查询的SQL语句相同**）。这是因为在两次查询过程中有另外一个事务插入数据造成的。

![](image/transaction2.jpg)

#### 幻读和不可重复读的区别
两者区别在于，不可重复读是指重复读取同一行的数据，每次结果都不同。幻读是查询一个范围，然后多次查询后，发现那个范围新增了数据或者减少了数据。

从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。

 - 对于前者, 只需要锁住满足条件的记录。
 - 对于后者, 要锁住满足条件及其相近的记录。

#### 隔离级别
显然，**脏读是坚决抵制的，不可重复读和幻读都是在很多情况下可以放松考虑**。

隔离级别就像一面墙，隔离不同的事务。对应表如下

![](image/transaction3.jpg)

##### 未授权读取READ_UNCOMMITTEED
也称为读未提交（Read Uncommitted）：允许脏读取，但不允许更新丢失。如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“**排他写锁**”实现。

##### 授权读取READ_COMMITTED
也称为读提交（Read Committed）：允许不可重复读取，但不允许脏读取。这可以通过“**瞬间共享读锁**”和“**排他写锁**”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。

##### 可重复读取REPEATABLE_READ
可重复读取（Repeatable Read）：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。这可以通过“**共享读锁**”和“**排他写锁**”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。

##### 序列化Serializable
序列化（Serializable）：提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

#### 场景
假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

**这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。**

### 实现
对于Mysql，在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

### 分布式事务
分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。

#### service多节点
随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护

![](image/transaction4.jpg)

这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。

#### resource多个节点
同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。

![](image/transaction5.jpg)

